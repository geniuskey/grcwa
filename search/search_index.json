{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to GRCWA Documentation","text":"<p>Autograd-enabled Rigorous Coupled Wave Analysis for Photonic Crystals</p> <p> GitHub  PyPI  Read the Docs</p>"},{"location":"#what-is-grcwa","title":"What is GRCWA?","text":"<p>Overview</p> <p>GRCWA (autoGradable Rigorous Coupled Wave Analysis) is a powerful Python library for simulating light interaction with periodic photonic structures. It implements the Rigorous Coupled Wave Analysis (RCWA) method with full support for automatic differentiation, making it ideal for inverse design and optimization of photonic devices.</p>"},{"location":"#material-features-key-features","title":":material-features: Key Features","text":""},{"location":"#physics-based-simulation","title":"Physics-Based Simulation","text":"<ul> <li> <p> Rigorous Simulation</p> <p>Solve Maxwell's equations exactly using Fourier modal method</p> <ul> <li>Full vectorial field calculations</li> <li>Arbitrary 2D periodic structures</li> <li>Multiple layer stacking</li> </ul> </li> <li> <p> Multiple Layers</p> <p>Support complex multilayer structures</p> <ul> <li>Independent dielectric profiles</li> <li>Uniform and patterned layers</li> <li>Unlimited layer count</li> </ul> </li> </ul>"},{"location":"#arbitrary-geometries","title":"Arbitrary Geometries","text":"Uniform LayersGrid-Based PatternsAnalytical Fourier <p>Simple dielectric slabs with constant permittivity</p> <pre><code>obj.Add_LayerUniform(thickness=0.5, epsilon=4.0)\n</code></pre> <p>Any 2D pattern with Cartesian grids</p> <pre><code>obj.Add_LayerGrid(thickness=0.3, Nx=400, Ny=400)\nobj.GridLayer_geteps(epsilon_grid.flatten())\n</code></pre> <p>Efficient for shapes with known Fourier series</p> <pre><code>obj.Add_LayerFourier(thickness=0.2, params)\n</code></pre>"},{"location":"#automatic-differentiation","title":"Automatic Differentiation","text":"<p>Gradient-Based Optimization</p> <p>Integrated with Autograd for automatic gradient computation</p> <p>Autogradable Parameters:</p> <ul> <li> Dielectric constants at every grid point</li> <li> Layer thicknesses</li> <li> Operating frequency</li> <li> Incident angles</li> <li> Lattice periodicity</li> </ul>"},{"location":"#flexible-lattices","title":"Flexible Lattices","text":"<ul> <li> <p>Square</p> <pre><code>L1 = [a, 0]\nL2 = [0, a]\n</code></pre> </li> <li> <p>Hexagonal</p> <pre><code>L1 = [a, 0]\nL2 = [a/2, a*\u221a3/2]\n</code></pre> </li> <li> <p>Arbitrary</p> <pre><code>L1 = [Lx1, Ly1]\nL2 = [Lx2, Ly2]\n</code></pre> </li> </ul>"},{"location":"#what-can-you-do-with-grcwa","title":"What Can You Do with GRCWA?","text":""},{"location":"#analysis-tasks","title":"Analysis Tasks","text":"<ul> <li>Compute reflection and transmission spectra</li> <li>Analyze diffraction orders</li> <li>Calculate electromagnetic fields in real and Fourier space</li> <li>Compute Poynting flux and energy flow</li> <li>Evaluate Maxwell stress tensors</li> </ul>"},{"location":"#design-optimization","title":"Design &amp; Optimization","text":"<ul> <li>Topology optimization of photonic structures</li> <li>Inverse design of metasurfaces</li> <li>Gradient-based optimization of:<ul> <li>Optical filters</li> <li>Anti-reflection coatings</li> <li>Photonic band gap structures</li> <li>Broadband reflectors</li> <li>Efficient light absorbers</li> </ul> </li> </ul>"},{"location":"#research-applications","title":"Research Applications","text":"<ul> <li>Photonic crystal design</li> <li>Metamaterial engineering</li> <li>Grating design</li> <li>Diffractive optics</li> <li>Solar cell optimization</li> <li>LIDAR component design</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<p>Here's a simple example to get you started:</p> <pre><code>import grcwa\nimport numpy as np\n\n# Define lattice and frequency\nL1 = [1.5, 0]  # Lattice vector 1\nL2 = [0, 1.5]  # Lattice vector 2\nfreq = 1.0     # Frequency (c=1)\ntheta = 0.0    # Incident angle\nphi = 0.0      # Azimuthal angle\nnG = 101       # Truncation order\n\n# Create RCWA object\nobj = grcwa.obj(nG, L1, L2, freq, theta, phi)\n\n# Add layers: vacuum + patterned + vacuum\nobj.Add_LayerUniform(1.0, 1.0)        # Vacuum layer\nobj.Add_LayerGrid(0.2, 400, 400)       # Patterned layer\nobj.Add_LayerUniform(1.0, 1.0)        # Vacuum layer\n\n# Setup reciprocal lattice\nobj.Init_Setup()\n\n# Define pattern (circular hole)\nNx, Ny = 400, 400\nx = np.linspace(0, 1, Nx)\ny = np.linspace(0, 1, Ny)\nX, Y = np.meshgrid(x, y, indexing='ij')\npattern = np.ones((Nx, Ny)) * 4.0  # Silicon (\u03b5=4)\nhole = (X-0.5)**2 + (Y-0.5)**2 &lt; 0.3**2\npattern[hole] = 1.0  # Air hole\n\n# Input pattern\nobj.GridLayer_geteps(pattern.flatten())\n\n# Setup excitation (p-polarized plane wave)\nobj.MakeExcitationPlanewave(p_amp=1, p_phase=0,\n                            s_amp=0, s_phase=0, order=0)\n\n# Solve for reflection and transmission\nR, T = obj.RT_Solve(normalize=1)\nprint(f'R = {R:.4f}, T = {T:.4f}, R+T = {R+T:.4f}')\n</code></pre>"},{"location":"#why-choose-grcwa","title":"Why Choose GRCWA?","text":"Feature GRCWA Traditional RCWA Automatic Differentiation \u2705 Built-in \u274c Manual derivation Optimization Ready \u2705 Direct integration \u274c Requires external tools Python Native \u2705 Easy to use \u26a0\ufe0f Often C/Fortran Arbitrary Patterns \u2705 Grid-based \u26a0\ufe0f Limited shapes Active Development \u2705 Open source \u26a0\ufe0f Varies"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li> <p> Quick Start</p> <p>Get up and running in minutes with our quick start guide</p> <p> Quick Start</p> </li> <li> <p> Learn the Theory</p> <p>Understand the physics and mathematics behind RCWA</p> <p> Theory</p> </li> <li> <p> API Reference</p> <p>Detailed documentation of all classes and functions</p> <p> API Docs</p> </li> <li> <p> Tutorials</p> <p>Step-by-step tutorials for common use cases</p> <p> Tutorials</p> </li> </ul>"},{"location":"#project-information","title":"Project Information","text":"<ul> <li>Author: Weiliang Jin (jwlaaa@gmail.com)</li> <li>Version: 0.1.2</li> <li>License: GPL v3</li> <li>Python: \u2265 3.5</li> <li>Repository: github.com/weiliangjinca/grcwa</li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>If you use GRCWA in your research, please cite:</p> <pre><code>@article{Jin2020,\n  title = {Inverse design of lightweight broadband reflector for relativistic lightsail propulsion},\n  author = {Jin, Weiliang and Li, Wei and Orenstein, Meir and Fan, Shanhui},\n  journal = {ACS Photonics},\n  volume = {7},\n  number = {9},\n  pages = {2350--2355},\n  year = {2020},\n  publisher = {ACS Publications}\n}\n</code></pre>"},{"location":"#need-help","title":"Need Help?","text":"<ul> <li>\ud83d\udcd6 Read the detailed documentation</li> <li>\ud83d\udca1 Check out examples</li> <li>\ud83d\udc1b Report issues on GitHub</li> <li>\ud83d\udce7 Contact the author at jwlaaa@gmail.com</li> </ul>"},{"location":"MATERIAL_FEATURES/","title":"Material for MkDocs Features","text":"<p>This document lists all the Material for MkDocs features enabled in this documentation.</p>"},{"location":"MATERIAL_FEATURES/#theme-features","title":"Theme Features","text":""},{"location":"MATERIAL_FEATURES/#navigation","title":"Navigation","text":"<ul> <li>\u2705 navigation.tabs - Top-level sections as tabs</li> <li>\u2705 navigation.tabs.sticky - Tabs remain visible when scrolling</li> <li>\u2705 navigation.sections - Render top-level sections as groups</li> <li>\u2705 navigation.expand - Expand all collapsible sections by default</li> <li>\u2705 navigation.path - Show breadcrumb navigation path</li> <li>\u2705 navigation.indexes - Section index pages (index.md)</li> <li>\u2705 navigation.top - \"Back to top\" button</li> <li>\u2705 navigation.footer - Previous/next page footer navigation</li> <li>\u2705 navigation.tracking - Anchor tracking in URL</li> </ul>"},{"location":"MATERIAL_FEATURES/#table-of-contents","title":"Table of Contents","text":"<ul> <li>\u2705 toc.follow - Sidebar scrolls to active anchor</li> <li>\u2705 toc.integrate - Integrate TOC into navigation</li> </ul>"},{"location":"MATERIAL_FEATURES/#search","title":"Search","text":"<ul> <li>\u2705 search.suggest - Search suggestions</li> <li>\u2705 search.highlight - Highlight search terms</li> <li>\u2705 search.share - Share search query via URL</li> </ul>"},{"location":"MATERIAL_FEATURES/#content","title":"Content","text":"<ul> <li>\u2705 content.code.copy - Copy button for code blocks</li> <li>\u2705 content.code.annotate - Code annotations (1)</li> <li>\u2705 content.tabs.link - Link content tabs across page</li> <li>\u2705 content.tooltips - Tooltips on hover</li> </ul>"},{"location":"MATERIAL_FEATURES/#header","title":"Header","text":"<ul> <li>\u2705 header.autohide - Auto-hide header on scroll</li> </ul>"},{"location":"MATERIAL_FEATURES/#announcement-bar","title":"Announcement Bar","text":"<ul> <li>\u2705 announce.dismiss - Dismissible announcement bar</li> </ul>"},{"location":"MATERIAL_FEATURES/#markdown-extensions","title":"Markdown Extensions","text":""},{"location":"MATERIAL_FEATURES/#python-markdown","title":"Python Markdown","text":"<ul> <li>\u2705 abbr - Abbreviations with tooltips (see includes/abbreviations.md)</li> <li>\u2705 admonition - Call-out boxes (!!! note, !!! warning, etc.)</li> <li>\u2705 attr_list - Add HTML attributes to Markdown elements</li> <li>\u2705 def_list - Definition lists</li> <li>\u2705 footnotes - Footnotes<sup>1</sup></li> <li>\u2705 md_in_html - Markdown inside HTML</li> <li>\u2705 tables - Tables</li> <li>\u2705 toc - Table of contents with permalinks</li> </ul>"},{"location":"MATERIAL_FEATURES/#pymdown-extensions","title":"PyMdown Extensions","text":"<ul> <li>\u2705 pymdownx.arithmatex - LaTeX math with MathJax: \\(E=mc^2\\)</li> <li>\u2705 pymdownx.betterem - Improved emphasis</li> <li>\u2705 pymdownx.caret - Insert (underline) and superscript (<sup>super</sup>)</li> <li>\u2705 pymdownx.mark - Highlight text (marked)</li> <li>\u2705 pymdownx.tilde - Delete (strikethrough) and subscript (<sub>sub</sub>)</li> <li>\u2705 pymdownx.critic - Track changes delete add</li> <li>\u2705 pymdownx.details - Collapsible admonitions (??? note)</li> <li>\u2705 pymdownx.emoji - Emoji support  </li> <li>\u2705 pymdownx.highlight - Syntax highlighting</li> <li>\u2705 pymdownx.inlinehilite - Inline code highlighting</li> <li>\u2705 pymdownx.keys - Keyboard keys Ctrl+C</li> <li>\u2705 pymdownx.magiclink - Auto-link URLs and repos</li> <li>\u2705 pymdownx.smartsymbols - Smart symbols \u00a9 \u2122 \u00ae \u2192 \u00a9 \u2122 \u00ae</li> <li>\u2705 pymdownx.snippets - Include external files</li> <li>\u2705 pymdownx.superfences - Nested code blocks and custom fences</li> <li>Mermaid diagrams</li> <li>Custom code blocks</li> <li>\u2705 pymdownx.tabbed - Tabbed content (=== \"Tab 1\")</li> <li>\u2705 pymdownx.tasklist - Task lists with checkboxes</li> </ul>"},{"location":"MATERIAL_FEATURES/#plugins","title":"Plugins","text":"<ul> <li>\u2705 search - Enhanced search with better tokenization</li> <li>\u2705 mkdocstrings - API documentation from docstrings</li> <li>\u2705 git-revision-date-localized - Show last update time</li> </ul>"},{"location":"MATERIAL_FEATURES/#extra-features","title":"Extra Features","text":""},{"location":"MATERIAL_FEATURES/#social-links","title":"Social Links","text":"<ul> <li> GitHub</li> <li> PyPI</li> <li> Email</li> </ul>"},{"location":"MATERIAL_FEATURES/#icons","title":"Icons","text":"<ul> <li>Material Design Icons (<code>:material-*:</code>)</li> <li>FontAwesome (<code>:fontawesome-*:</code>)</li> <li>Octicons (<code>:octicons-*:</code>)</li> </ul>"},{"location":"MATERIAL_FEATURES/#analytics-optional","title":"Analytics (Optional)","text":"<ul> <li>Google Analytics with feedback widget</li> </ul>"},{"location":"MATERIAL_FEATURES/#versioning","title":"Versioning","text":"<ul> <li>Mike for version management (if needed)</li> </ul>"},{"location":"MATERIAL_FEATURES/#examples","title":"Examples","text":""},{"location":"MATERIAL_FEATURES/#admonitions","title":"Admonitions","text":"<p>This is a note</p> <p>This is the content of the note.</p> <p>This is a warning</p> <p>This is the content of the warning.</p> <p>Pro Tip</p> <p>This is a helpful tip.</p> <p>Example</p> <p>This is an example.</p> <p>Summary</p> <p>This is a summary.</p> Collapsible Info <p>This content is hidden by default.</p>"},{"location":"MATERIAL_FEATURES/#tabs","title":"Tabs","text":"Tab 1Tab 2Tab 3 <p>Content for tab 1</p> <p>Content for tab 2</p> <p>Content for tab 3</p>"},{"location":"MATERIAL_FEATURES/#grid-cards","title":"Grid Cards","text":"<ul> <li> <p> Fast</p> <p>Get up and running quickly</p> </li> <li> <p> Beautiful</p> <p>Material Design aesthetics</p> </li> <li> <p> Powerful</p> <p>Full-featured documentation</p> </li> </ul>"},{"location":"MATERIAL_FEATURES/#task-lists","title":"Task Lists","text":"<ul> <li> Task 1 completed</li> <li> Task 2 completed</li> <li> Task 3 pending</li> <li> Task 4 pending</li> </ul>"},{"location":"MATERIAL_FEATURES/#math","title":"Math","text":"<p>Inline math: \\(E = mc^2\\)</p> <p>Block math:</p> \\[ \\nabla \\times \\mathbf{E} = -\\frac{\\partial \\mathbf{B}}{\\partial t} \\]"},{"location":"MATERIAL_FEATURES/#keyboard-keys","title":"Keyboard Keys","text":"<p>Press Ctrl+C to copy and Ctrl+V to paste.</p>"},{"location":"MATERIAL_FEATURES/#text-formatting","title":"Text Formatting","text":"<ul> <li>Bold text</li> <li>Italic text</li> <li>Highlighted text</li> <li>Inserted text</li> <li>Deleted text</li> <li>H<sub>2</sub>O (subscript)</li> <li>x<sup>2</sup> (superscript)</li> </ul>"},{"location":"MATERIAL_FEATURES/#footnotes","title":"Footnotes","text":"<p>This is a sentence with a footnote.<sup>1</sup></p>"},{"location":"MATERIAL_FEATURES/#abbreviations","title":"Abbreviations","text":"<p>The RCWA method (hover to see definition) is implemented in GRCWA.</p>"},{"location":"MATERIAL_FEATURES/#critic-markup","title":"Critic Markup","text":"<p>Removed text</p> <p>Added text</p> <p>OldNew</p> <p>Highlighted</p> Comment"},{"location":"MATERIAL_FEATURES/#buttons","title":"Buttons","text":"<p>Primary Button Regular Button</p>"},{"location":"MATERIAL_FEATURES/#mermaid-diagrams","title":"Mermaid Diagrams","text":"<pre><code>graph LR\n    A[Start] --&gt; B{Decision}\n    B --&gt;|Yes| C[Action 1]\n    B --&gt;|No| D[Action 2]\n    C --&gt; E[End]\n    D --&gt; E</code></pre>"},{"location":"MATERIAL_FEATURES/#code-annotations","title":"Code Annotations","text":"<pre><code>def hello_world():  # (1)!\n    print(\"Hello, World!\")  # (2)!\n</code></pre> <ol> <li>This defines a function</li> <li>This prints a message</li> </ol>"},{"location":"MATERIAL_FEATURES/#custom-css-classes","title":"Custom CSS Classes","text":""},{"location":"MATERIAL_FEATURES/#text-alignment","title":"Text Alignment","text":"<p>This text is centered</p> <p>This text is right-aligned</p>"},{"location":"MATERIAL_FEATURES/#highlight-box","title":"Highlight Box","text":"<p>This is a highlighted box with special styling.</p>"},{"location":"MATERIAL_FEATURES/#responsive-design","title":"Responsive Design","text":"<p>The documentation is fully responsive and works on:</p> <ul> <li>\ud83d\udda5\ufe0f Desktop (1920px+)</li> <li>\ud83d\udcbb Laptop (1366px - 1920px)</li> <li>\ud83d\udcf1 Tablet (768px - 1366px)</li> <li>\ud83d\udcf1 Mobile (&lt; 768px)</li> </ul>"},{"location":"MATERIAL_FEATURES/#dark-mode","title":"Dark Mode","text":"<p>Toggle between light and dark themes using the button in the header.</p> <ul> <li>Light mode: Clean, bright interface</li> <li>Dark mode: Easy on the eyes for night reading</li> </ul>"},{"location":"MATERIAL_FEATURES/#accessibility","title":"Accessibility","text":"<ul> <li>\u267f Keyboard navigation</li> <li>\ud83d\udd0d High contrast mode support</li> <li>\ud83d\udcd6 Screen reader friendly</li> <li>\ud83c\udfaf Focus indicators</li> <li>\ud83d\udcdd Semantic HTML</li> </ul> <p>For more information, see the Material for MkDocs documentation.</p> <ol> <li> <p>This is the footnote content.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"installation/","title":"Installation Guide","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<p>GRCWA requires Python 3.5 or later. The core dependencies are:</p> <ul> <li>numpy: Numerical computing</li> <li>autograd: Automatic differentiation</li> </ul> <p>Optional dependencies:</p> <ul> <li>nlopt: For optimization examples (topology optimization)</li> <li>matplotlib: For visualization</li> <li>pytest: For running tests</li> </ul>"},{"location":"installation/#installation-methods","title":"Installation Methods","text":""},{"location":"installation/#method-1-install-from-pypi-recommended","title":"Method 1: Install from PyPI (Recommended)","text":"<p>The simplest way to install GRCWA is via pip:</p> <pre><code>pip install grcwa\n</code></pre> <p>This will automatically install numpy and autograd.</p>"},{"location":"installation/#method-2-install-from-source","title":"Method 2: Install from Source","text":"<p>For the latest development version:</p> <pre><code># Clone the repository\ngit clone https://github.com/weiliangjinca/grcwa.git\ncd grcwa\n\n# Install in development mode\npip install -e .\n</code></pre> <p>Development mode (<code>-e</code>) allows you to modify the source code and have changes reflected immediately.</p>"},{"location":"installation/#method-3-install-with-optional-dependencies","title":"Method 3: Install with Optional Dependencies","text":"<p>To install with optimization support:</p> <pre><code>pip install grcwa nlopt matplotlib\n</code></pre>"},{"location":"installation/#verify-installation","title":"Verify Installation","text":"<p>Test your installation:</p> <pre><code>import grcwa\nimport numpy as np\n\nprint(f\"GRCWA imported successfully!\")\nprint(f\"NumPy version: {np.__version__}\")\n\n# Test backend\ngrcwa.set_backend('numpy')\nprint(\"NumPy backend: OK\")\n\ngrcwa.set_backend('autograd')\nprint(\"Autograd backend: OK\")\n</code></pre> <p>Run a quick simulation:</p> <pre><code>import grcwa\nimport numpy as np\n\n# Simple 3-layer structure\nobj = grcwa.obj(nG=101, L1=[1,0], L2=[0,1],\n                freq=1.0, theta=0, phi=0, verbose=0)\nobj.Add_LayerUniform(1.0, 1.0)  # vacuum\nobj.Add_LayerUniform(0.5, 4.0)  # dielectric slab\nobj.Add_LayerUniform(1.0, 1.0)  # vacuum\nobj.Init_Setup()\n\n# Excitation\nobj.MakeExcitationPlanewave(p_amp=1, p_phase=0,\n                            s_amp=0, s_phase=0, order=0)\n\n# Solve\nR, T = obj.RT_Solve(normalize=1)\nprint(f\"R = {R:.4f}, T = {T:.4f}, R+T = {R+T:.4f}\")\n</code></pre> <p>Expected output: <pre><code>R = 0.3600, T = 0.6400, R+T = 1.0000\n</code></pre></p>"},{"location":"installation/#setting-up-development-environment","title":"Setting Up Development Environment","text":"<p>If you plan to contribute or modify GRCWA:</p>"},{"location":"installation/#1-create-virtual-environment","title":"1. Create Virtual Environment","text":"<pre><code># Using venv\npython -m venv grcwa_env\nsource grcwa_env/bin/activate  # On Windows: grcwa_env\\Scripts\\activate\n\n# Using conda\nconda create -n grcwa python=3.8\nconda activate grcwa\n</code></pre>"},{"location":"installation/#2-install-development-dependencies","title":"2. Install Development Dependencies","text":"<pre><code>pip install -e \".[dev]\"\n</code></pre> <p>Or manually:</p> <pre><code>pip install pytest pytest-cov flake8 sphinx\n</code></pre>"},{"location":"installation/#3-run-tests","title":"3. Run Tests","text":"<pre><code># Run all tests\npytest tests/\n\n# Run specific test\npytest tests/test_rcwa.py::test_rcwa\n\n# Run with coverage\npytest --cov=grcwa tests/\n</code></pre>"},{"location":"installation/#backend-configuration","title":"Backend Configuration","text":"<p>GRCWA supports two computational backends:</p>"},{"location":"installation/#numpy-backend-default","title":"NumPy Backend (Default)","text":"<p>Standard NumPy operations - fast, but no automatic differentiation:</p> <pre><code>import grcwa\ngrcwa.set_backend('numpy')\n</code></pre> <p>Use this when: - You only need forward simulation (R, T, fields) - Maximum performance is required - Gradients are not needed</p>"},{"location":"installation/#autograd-backend","title":"Autograd Backend","text":"<p>Autograd-compatible NumPy - enables automatic differentiation:</p> <pre><code>import grcwa\ngrcwa.set_backend('autograd')\n</code></pre> <p>Use this when: - You need gradients for optimization - Performing inverse design - Computing parameter sensitivities</p> <p>Backend Compatibility</p> <p>Once you switch to autograd backend, make sure all your arrays are created with autograd.numpy, not standard numpy:</p> <pre><code>import autograd.numpy as np  # Use this\n# not: import numpy as np\n</code></pre>"},{"location":"installation/#common-installation-issues","title":"Common Installation Issues","text":""},{"location":"installation/#issue-no-module-named-autograd","title":"Issue: \"No module named autograd\"","text":"<p>Solution: Install autograd: <pre><code>pip install autograd\n</code></pre></p>"},{"location":"installation/#issue-numpy-version-conflict","title":"Issue: Numpy version conflict","text":"<p>Solution: Ensure compatible numpy version: <pre><code>pip install --upgrade numpy autograd\n</code></pre></p>"},{"location":"installation/#issue-importerror-cannot-import-name-obj","title":"Issue: \"ImportError: cannot import name 'obj'\"","text":"<p>Solution: Make sure you're importing from the package: <pre><code>import grcwa\nobj = grcwa.obj(...)  # Correct\n\n# Not:\nfrom grcwa import obj  # May not work in older versions\n</code></pre></p>"},{"location":"installation/#issue-tests-fail-with-modulenotfounderror","title":"Issue: Tests fail with \"ModuleNotFoundError\"","text":"<p>Solution: Install test dependencies: <pre><code>pip install pytest\n</code></pre></p>"},{"location":"installation/#issue-nlopt-not-available","title":"Issue: NLOPT not available","text":"<p>NLOPT is optional and only needed for optimization examples.</p> <p>Linux: <pre><code>pip install nlopt\n</code></pre></p> <p>Mac (with Homebrew): <pre><code>brew install nlopt\npip install nlopt\n</code></pre></p> <p>Windows: Use conda: <pre><code>conda install -c conda-forge nlopt\n</code></pre></p>"},{"location":"installation/#docker-installation-optional","title":"Docker Installation (Optional)","text":"<p>For a reproducible environment:</p> <p>Create <code>Dockerfile</code>: <pre><code>FROM python:3.8-slim\n\nRUN pip install grcwa nlopt matplotlib jupyter\n\nWORKDIR /workspace\n\nCMD [\"jupyter\", \"notebook\", \"--ip=0.0.0.0\", \"--allow-root\"]\n</code></pre></p> <p>Build and run: <pre><code>docker build -t grcwa .\ndocker run -p 8888:8888 -v $(pwd):/workspace grcwa\n</code></pre></p>"},{"location":"installation/#platform-specific-notes","title":"Platform-Specific Notes","text":""},{"location":"installation/#linux","title":"Linux","text":"<p>Should work out of the box with pip.</p>"},{"location":"installation/#macos","title":"macOS","text":"<p>May need Xcode command line tools: <pre><code>xcode-select --install\n</code></pre></p>"},{"location":"installation/#windows","title":"Windows","text":"<p>Works with standard Python installation. If using Anaconda: <pre><code>conda install numpy autograd\npip install grcwa\n</code></pre></p>"},{"location":"installation/#performance-optimization","title":"Performance Optimization","text":""},{"location":"installation/#numpy-with-mkl","title":"NumPy with MKL","text":"<p>For better performance, use NumPy built with Intel MKL:</p> <pre><code># With conda\nconda install numpy scipy mkl\n\n# Verify\npython -c \"import numpy; numpy.show_config()\"\n</code></pre>"},{"location":"installation/#parallel-computing","title":"Parallel Computing","text":"<p>GRCWA itself doesn't use multi-threading, but you can parallelize parameter sweeps:</p> <pre><code>from multiprocessing import Pool\n\ndef compute_spectrum(freq):\n    obj = grcwa.obj(...)\n    # ... setup ...\n    R, T = obj.RT_Solve()\n    return R, T\n\nfreqs = np.linspace(0.5, 1.5, 50)\nwith Pool(8) as p:\n    results = p.map(compute_spectrum, freqs)\n</code></pre>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<p>Now that GRCWA is installed:</p> <ol> <li>Quick Start Guide: Run your first simulation</li> <li>Basic Concepts: Understand the workflow</li> <li>Examples: Explore example simulations</li> <li>Tutorials: Step-by-step learning</li> </ol>"},{"location":"installation/#getting-help","title":"Getting Help","text":"<p>If you encounter problems:</p> <ul> <li>Check the Troubleshooting guide</li> <li>Read the FAQ</li> <li>Open an issue on GitHub</li> <li>Contact: jwlaaa@gmail.com</li> </ul>"},{"location":"introduction/","title":"Introduction to RCWA","text":""},{"location":"introduction/#what-is-rigorous-coupled-wave-analysis","title":"What is Rigorous Coupled Wave Analysis?","text":"<p>Rigorous Coupled Wave Analysis (RCWA), also known as Fourier Modal Method (FMM), is a semi-analytical method for solving Maxwell's equations in periodic structures. It's one of the most widely used techniques for analyzing electromagnetic wave interaction with periodic photonic structures such as:</p> <ul> <li>Diffraction gratings: Used in spectrometers, wavelength division multiplexers</li> <li>Photonic crystals: Band gap materials for controlling light propagation</li> <li>Metasurfaces: Subwavelength structured surfaces for wavefront control</li> <li>Solar cells: Periodic textures for light trapping</li> <li>Anti-reflection coatings: Moth-eye structures</li> <li>Optical filters: Wavelength-selective devices</li> </ul>"},{"location":"introduction/#why-rcwa","title":"Why RCWA?","text":""},{"location":"introduction/#advantages","title":"Advantages","text":"Rigorous Solution <p>Unlike approximate methods (ray tracing, scalar diffraction), RCWA solves Maxwell's equations exactly (within numerical precision). This is critical for:</p> <ul> <li>Subwavelength structures where ray optics fails</li> <li>High refractive index contrasts</li> <li>Near-field effects</li> <li>Strong coupling between diffraction orders</li> </ul> Efficiency <p>For periodic structures, RCWA is much faster than finite-element or finite-difference time-domain (FDTD) methods because:</p> <ul> <li>Periodicity reduces 3D problem to unit cell analysis</li> <li>Fourier representation efficiently handles smooth features</li> <li>No need to mesh large computational domains</li> </ul> Flexibility <p>Can handle:</p> <ul> <li>Arbitrary 2D periodic patterns</li> <li>Multiple layers with different periods (super-cells)</li> <li>Anisotropic and dispersive materials</li> <li>Oblique incidence at any angle</li> </ul>"},{"location":"introduction/#when-to-use-rcwa","title":"When to Use RCWA","text":"<p>\u2705 RCWA is ideal for:</p> <ul> <li>Structures with 2D periodicity (infinite in lateral directions)</li> <li>Spectral analysis (frequency sweeps)</li> <li>Angle-resolved measurements</li> <li>Structures with well-defined layers (z-invariant in each layer)</li> <li>Optimization problems (with GRCWA's autograd capability)</li> </ul> <p>\u274c Consider alternatives for:</p> <ul> <li>Aperiodic structures \u2192 Use FDTD, FEM</li> <li>3D arbitrary geometries \u2192 Use FDTD, FEM</li> <li>Ultra-broadband simulations \u2192 Use FDTD (RCWA needs frequency sweeps)</li> <li>Nonlinear optics \u2192 Use nonlinear FDTD/FEM</li> </ul>"},{"location":"introduction/#the-physical-picture","title":"The Physical Picture","text":""},{"location":"introduction/#incident-wave","title":"Incident Wave","text":"<p>A plane wave strikes a periodic structure at angle \\((\\theta, \\phi)\\):</p> \\[ \\mathbf{E}_{\\text{inc}} = \\mathbf{E}_0 e^{i(\\mathbf{k} \\cdot \\mathbf{r} - \\omega t)} \\] <p>where:</p> <ul> <li>\\(\\mathbf{k} = k_x \\hat{x} + k_y \\hat{y} + k_z \\hat{z}\\) is the wave vector</li> <li>\\(\\omega = 2\\pi f\\) is the angular frequency</li> <li>\\(\\theta\\) is the polar angle (from z-axis)</li> <li>\\(\\phi\\) is the azimuthal angle (in xy-plane)</li> </ul>"},{"location":"introduction/#periodic-structure","title":"Periodic Structure","text":"<p>The structure has dielectric function \\(\\varepsilon(\\mathbf{r})\\) that is periodic in x and y:</p> \\[ \\varepsilon(\\mathbf{r} + \\mathbf{L}_1) = \\varepsilon(\\mathbf{r}) \\] \\[ \\varepsilon(\\mathbf{r} + \\mathbf{L}_2) = \\varepsilon(\\mathbf{r}) \\] <p>where \\(\\mathbf{L}_1\\) and \\(\\mathbf{L}_2\\) are the lattice vectors.</p> <p>Figure: Multi-layer periodic structure. Each layer can have different 2D periodic pattern.</p>"},{"location":"introduction/#diffraction-orders","title":"Diffraction Orders","text":"<p>Due to periodicity, the incident wave couples to diffraction orders characterized by reciprocal lattice vectors \\(\\mathbf{G}_{mn}\\):</p> \\[ \\mathbf{k}_{mn} = \\mathbf{k}_{\\parallel,0} + \\mathbf{G}_{mn} \\] <p>where:</p> <ul> <li>\\((m, n)\\) are integer indices</li> <li>\\(\\mathbf{k}_{\\parallel,0} = k_x \\hat{x} + k_y \\hat{y}\\) is the incident wave's in-plane momentum</li> <li>\\(\\mathbf{G}_{mn} = m\\mathbf{K}_1 + n\\mathbf{K}_2\\) are reciprocal lattice vectors</li> </ul> <p>Each diffraction order propagates at a different angle, carrying power away from the structure.</p>"},{"location":"introduction/#layer-by-layer-analysis","title":"Layer-by-Layer Analysis","text":"<p>RCWA divides the structure into layers:</p> <ol> <li>Uniform exterior regions (input/output): Analytically solvable</li> <li>Patterned layers: Each layer has constant z-profile but 2D periodic pattern</li> <li>Uniform interior layers: Simple analytical solutions</li> </ol> <p>Within each layer, fields are expanded in Fourier series (harmonics):</p> \\[ \\mathbf{E}(\\mathbf{r}) = \\sum_{m,n} \\mathbf{E}_{mn}(z) e^{i\\mathbf{k}_{mn} \\cdot \\mathbf{r}_{\\parallel}} \\]"},{"location":"introduction/#key-concepts","title":"Key Concepts","text":""},{"location":"introduction/#blochs-theorem","title":"Bloch's Theorem","text":"<p>In periodic structures, electromagnetic modes satisfy Bloch's theorem:</p> \\[ \\mathbf{E}(\\mathbf{r} + \\mathbf{L}) = e^{i\\mathbf{k} \\cdot \\mathbf{L}} \\mathbf{E}(\\mathbf{r}) \\] <p>This allows us to solve only within one unit cell and use boundary conditions to construct the full solution.</p>"},{"location":"introduction/#evanescent-vs-propagating-modes","title":"Evanescent vs. Propagating Modes","text":"<p>Each diffraction order \\((m,n)\\) has a \\(z\\)-component of the wave vector:</p> \\[ k_{z,mn} = \\sqrt{\\varepsilon \\omega^2 - k_{x,mn}^2 - k_{y,mn}^2} \\] <ul> <li>Propagating modes: \\(k_z\\) is real \u2192 carries power to far field</li> <li>Evanescent modes: \\(k_z\\) is imaginary \u2192 decays exponentially, stores near-field energy</li> </ul> <p>High diffraction orders are typically evanescent, but must be included for accurate near-field calculations.</p>"},{"location":"introduction/#energy-conservation","title":"Energy Conservation","text":"<p>For lossless structures, energy must be conserved:</p> \\[ R + T = 1 \\] <p>where:</p> <ul> <li>\\(R\\) = total reflected power</li> <li>\\(T\\) = total transmitted power</li> </ul> <p>This serves as a numerical check for convergence.</p>"},{"location":"introduction/#the-rcwa-workflow","title":"The RCWA Workflow","text":"<pre><code>graph TD\n    A[Define Structure] --&gt; B[Setup Lattice &amp; Frequency]\n    B --&gt; C[Add Layers]\n    C --&gt; D[Initialize Reciprocal Lattice]\n    D --&gt; E[Input Dielectric Patterns]\n    E --&gt; F[Define Excitation]\n    F --&gt; G[Solve Eigenvalue Problem]\n    G --&gt; H[Compute S-Matrix]\n    H --&gt; I[Solve Boundary Conditions]\n    I --&gt; J[Calculate R, T, Fields]</code></pre>"},{"location":"introduction/#step-by-step-process","title":"Step-by-Step Process","text":"<ol> <li>Define geometry: Lattice vectors, layer thicknesses</li> <li>Setup RCWA object: Frequency, incident angles, truncation order</li> <li>Add layers: Uniform or patterned</li> <li>Initialize: Compute reciprocal lattice</li> <li>Input patterns: For patterned layers, provide \u03b5(x,y)</li> <li>Setup excitation: Plane wave amplitude and polarization</li> <li>Solve: RCWA computes reflection, transmission, fields</li> </ol>"},{"location":"introduction/#what-makes-grcwa-special","title":"What Makes GRCWA Special?","text":""},{"location":"introduction/#standard-rcwa","title":"Standard RCWA","text":"<pre><code># Compute R, T\nR, T = rcwa_solve(structure, freq)\n</code></pre>"},{"location":"introduction/#grcwa-with-autograd","title":"GRCWA with Autograd","text":"<pre><code>import autograd.numpy as np\nfrom autograd import grad\n\ndef objective(epsilon):\n    R, T = grcwa_solve(structure, epsilon, freq)\n    return -R  # Maximize reflection\n\n# Automatic gradient!\ngrad_objective = grad(objective)\ngradient = grad_objective(epsilon)\n</code></pre> <p>The ability to automatically compute gradients enables:</p> <ul> <li>Topology optimization: Design arbitrary patterns pixel-by-pixel</li> <li>Inverse design: Start from target spectrum, optimize structure</li> <li>Rapid prototyping: No need to derive adjoint equations manually</li> <li>Complex objectives: Optimize multi-objective functions easily</li> </ul>"},{"location":"introduction/#comparison-with-other-methods","title":"Comparison with Other Methods","text":"Method Dimensionality Speed Flexibility Far-field Near-field RCWA 2D periodic Fast Periodic only \u2705 Excellent \u2705 Good FDTD 2D/3D Moderate Any geometry \u2705 Good \u2705 Excellent FEM 2D/3D Slow Any geometry \u26a0\ufe0f Requires PML \u2705 Excellent Ray Tracing 3D Very fast Any geometry \u2705 Good \u274c Invalid T-Matrix 3D particles Fast Spheroids \u2705 Excellent \u26a0\ufe0f Limited"},{"location":"introduction/#physical-units-and-conventions","title":"Physical Units and Conventions","text":"<p>GRCWA uses natural units where:</p> \\[ \\varepsilon_0 = \\mu_0 = c = 1 \\] <p>This means:</p> <ul> <li>Length: Arbitrary (choose your own unit, e.g., \u03bcm)</li> <li>Frequency: \\(f = c/\\lambda = 1/\\lambda\\) (in your length units)</li> <li>Time harmonic: \\(e^{-i\\omega t}\\) convention</li> <li>Impedance: \\(Z = \\sqrt{\\mu_0/\\varepsilon_0} = 1\\)</li> </ul>"},{"location":"introduction/#example","title":"Example","text":"<p>For a structure at wavelength \\(\\lambda = 1.5\\) \u03bcm:</p> <pre><code>wavelength = 1.5  # \u03bcm\nfreq = 1.0 / wavelength  # freq = 0.6667 in units where c=1\n</code></pre> <p>All lengths (lattice constants, thicknesses) should also be in \u03bcm.</p>"},{"location":"introduction/#next-steps","title":"Next Steps","text":"<p>Now that you understand what RCWA is and what GRCWA offers, proceed to:</p> <ul> <li>Installation: Install GRCWA</li> <li>Quick Start: Run your first simulation</li> <li>Physical Principles: Deep dive into the physics</li> <li>Mathematical Formulation: Understand the equations</li> </ul>"},{"location":"quickstart/","title":"Quick Start Guide","text":"<p>This guide will get you running your first RCWA simulation in minutes!</p>"},{"location":"quickstart/#your-first-simulation","title":"Your First Simulation","text":"<p>Let's simulate a simple dielectric slab (like a glass plate) and compute how much light it reflects and transmits.</p>"},{"location":"quickstart/#complete-example","title":"Complete Example","text":"<pre><code>import grcwa\nimport numpy as np\n\n# Step 1: Define the structure parameters\nL1 = [1.0, 0]    # Lattice vector 1 (x-direction)\nL2 = [0, 1.0]    # Lattice vector 2 (y-direction)\nfreq = 1.0       # Frequency (wavelength = 1.0 in our units)\ntheta = 0.0      # Normal incidence\nphi = 0.0        # Azimuthal angle\nnG = 101         # Number of Fourier harmonics\n\n# Step 2: Create RCWA object\nobj = grcwa.obj(nG, L1, L2, freq, theta, phi, verbose=1)\n\n# Step 3: Define layers (from top to bottom)\nobj.Add_LayerUniform(1.0, 1.0)   # Top: vacuum (\u03b5=1), thickness=1.0\nobj.Add_LayerUniform(0.5, 4.0)   # Middle: dielectric slab (\u03b5=4), thickness=0.5\nobj.Add_LayerUniform(1.0, 1.0)   # Bottom: vacuum (\u03b5=1), thickness=1.0\n\n# Step 4: Initialize\nobj.Init_Setup()\n\n# Step 5: Define incident wave (p-polarized, amplitude=1)\nobj.MakeExcitationPlanewave(p_amp=1, p_phase=0,\n                            s_amp=0, s_phase=0,\n                            order=0)\n\n# Step 6: Solve\nR, T = obj.RT_Solve(normalize=1)\n\n# Step 7: Display results\nprint(f\"Reflection: R = {R:.4f}\")\nprint(f\"Transmission: T = {T:.4f}\")\nprint(f\"Energy conservation: R + T = {R+T:.4f}\")\n</code></pre> <p>Output: <pre><code>Reflection: R = 0.3600\nTransmission: T = 0.6400\nEnergy conservation: R + T = 1.0000\n</code></pre></p>"},{"location":"quickstart/#understanding-the-code","title":"Understanding the Code","text":""},{"location":"quickstart/#step-1-structure-parameters","title":"Step 1: Structure Parameters","text":"<pre><code>L1 = [1.0, 0]    # Lattice vector 1\nL2 = [0, 1.0]    # Lattice vector 2\n</code></pre> <p>These define the periodicity of your structure. For this simple slab, periodicity doesn't matter, but RCWA always assumes periodic structures.</p> <pre><code>freq = 1.0\n</code></pre> <p>In natural units (c=1), frequency = 1/wavelength. So <code>freq=1.0</code> means wavelength=1.0.</p> <pre><code>theta = 0.0  # Angle from z-axis (normal incidence)\nphi = 0.0    # Angle in xy-plane\n</code></pre> <p>For normal incidence, set both angles to zero.</p> <pre><code>nG = 101\n</code></pre> <p>Number of Fourier harmonics to include. Higher = more accurate but slower. For uniform slabs, even <code>nG=1</code> would work, but for patterned layers you need larger values (100-300 typical).</p>"},{"location":"quickstart/#step-2-create-rcwa-object","title":"Step 2: Create RCWA Object","text":"<pre><code>obj = grcwa.obj(nG, L1, L2, freq, theta, phi, verbose=1)\n</code></pre> <p>This creates the main RCWA solver object. <code>verbose=1</code> prints progress information.</p>"},{"location":"quickstart/#step-3-add-layers","title":"Step 3: Add Layers","text":"<pre><code>obj.Add_LayerUniform(thickness, epsilon)\n</code></pre> <p>Layers are added from top to bottom (input to output):</p> <ul> <li>Layer 0: Top vacuum (semi-infinite)</li> <li>Layer 1: Dielectric slab</li> <li>Layer 2: Bottom vacuum (semi-infinite)</li> </ul> <p>Layer Order</p> <p>Always define layers in the order light encounters them: Input region \u2192 Layer 1 \u2192 Layer 2 \u2192 ... \u2192 Output region</p>"},{"location":"quickstart/#step-4-initialize","title":"Step 4: Initialize","text":"<pre><code>obj.Init_Setup()\n</code></pre> <p>This computes: - Reciprocal lattice vectors - Wave vectors for all diffraction orders - Eigenvalues for uniform layers</p>"},{"location":"quickstart/#step-5-define-excitation","title":"Step 5: Define Excitation","text":"<pre><code>obj.MakeExcitationPlanewave(p_amp=1, p_phase=0,\n                            s_amp=0, s_phase=0,\n                            order=0)\n</code></pre> <p>Parameters: - <code>p_amp</code>: P-polarization amplitude (TM) - <code>s_amp</code>: S-polarization amplitude (TE) - <code>p_phase</code>, <code>s_phase</code>: Phases in radians - <code>order=0</code>: Incident in the 0<sup>th</sup> diffraction order (normally incident)</p>"},{"location":"quickstart/#step-6-solve","title":"Step 6: Solve","text":"<pre><code>R, T = obj.RT_Solve(normalize=1)\n</code></pre> <ul> <li><code>normalize=1</code>: Normalize by incident power and medium properties</li> <li>Returns total reflection (R) and transmission (T) powers</li> </ul>"},{"location":"quickstart/#step-7-check-energy-conservation","title":"Step 7: Check Energy Conservation","text":"<p>For lossless materials: <pre><code>assert abs(R + T - 1.0) &lt; 1e-6, \"Energy not conserved!\"\n</code></pre></p>"},{"location":"quickstart/#example-2-patterned-layer","title":"Example 2: Patterned Layer","text":"<p>Now let's simulate something more interesting: a photonic crystal slab with circular holes.</p> <pre><code>import grcwa\nimport numpy as np\n\n# Setup\nL1 = [1.5, 0]\nL2 = [0, 1.5]\nfreq = 1.0\ntheta = 0.0\nphi = 0.0\nnG = 201  # Need more harmonics for patterned layers\n\nobj = grcwa.obj(nG, L1, L2, freq, theta, phi, verbose=1)\n\n# Layer structure\nobj.Add_LayerUniform(1.0, 1.0)        # vacuum\nobj.Add_LayerGrid(0.3, 400, 400)      # patterned layer: 400\u00d7400 grid\nobj.Add_LayerUniform(1.0, 1.0)        # vacuum\n\nobj.Init_Setup()\n\n# Create pattern: Silicon slab with circular air hole\nNx, Ny = 400, 400\nx = np.linspace(0, 1, Nx)  # Normalized coordinates [0,1]\ny = np.linspace(0, 1, Ny)\nX, Y = np.meshgrid(x, y, indexing='ij')\n\n# Start with silicon (\u03b5=12)\nepsilon = np.ones((Nx, Ny)) * 12.0\n\n# Add circular air hole (\u03b5=1) at center\nradius = 0.4  # In units of lattice constant\nhole = (X - 0.5)**2 + (Y - 0.5)**2 &lt; radius**2\nepsilon[hole] = 1.0\n\n# Input the pattern\nobj.GridLayer_geteps(epsilon.flatten())\n\n# Excitation\nobj.MakeExcitationPlanewave(p_amp=1, p_phase=0,\n                            s_amp=0, s_phase=0, order=0)\n\n# Solve\nR, T = obj.RT_Solve(normalize=1)\nprint(f\"R = {R:.4f}, T = {T:.4f}, R+T = {R+T:.4f}\")\n\n# Get reflection/transmission by order\nRi, Ti = obj.RT_Solve(normalize=1, byorder=1)\nprint(f\"\\nNumber of diffraction orders: {len(Ri)}\")\nprint(f\"Reflection in 0th order: {Ri[0]:.4f}\")\nprint(f\"Transmission in 0th order: {Ti[0]:.4f}\")\n</code></pre>"},{"location":"quickstart/#key-differences","title":"Key Differences","text":"<p>Grid-based layer: <pre><code>obj.Add_LayerGrid(thickness, Nx, Ny)\n</code></pre></p> <p>Instead of uniform dielectric, we define a 2D grid with <code>Nx \u00d7 Ny</code> points.</p> <p>Pattern definition: <pre><code>epsilon = np.ones((Nx, Ny)) * 12.0  # Background\nepsilon[hole] = 1.0                  # Hole\nobj.GridLayer_geteps(epsilon.flatten())\n</code></pre></p> <p>Create a 2D array of dielectric constants, then flatten and input.</p> <p>By-order analysis: <pre><code>Ri, Ti = obj.RT_Solve(normalize=1, byorder=1)\n</code></pre></p> <p>Get arrays of R and T for each diffraction order.</p>"},{"location":"quickstart/#example-3-angle-dependent-response","title":"Example 3: Angle-Dependent Response","text":"<p>Compute reflection vs. incident angle:</p> <pre><code>import grcwa\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Setup structure\nL1 = [0.6, 0]\nL2 = [0, 0.6]\nfreq = 1.0\nnG = 101\n\n# Angle sweep\nangles = np.linspace(0, 80, 50) * np.pi/180  # 0\u00b0 to 80\u00b0\nR_list = []\n\nfor theta in angles:\n    obj = grcwa.obj(nG, L1, L2, freq, theta, phi=0, verbose=0)\n\n    # Bragg mirror: alternating layers\n    for i in range(5):\n        if i % 2 == 0:\n            obj.Add_LayerUniform(0.125, 4.0)  # High index\n        else:\n            obj.Add_LayerUniform(0.125, 2.25) # Low index\n\n    obj.Init_Setup()\n    obj.MakeExcitationPlanewave(1, 0, 0, 0, order=0)\n\n    R, T = obj.RT_Solve(normalize=1)\n    R_list.append(R)\n\n# Plot\nplt.figure(figsize=(8, 5))\nplt.plot(angles * 180/np.pi, R_list, 'b-', linewidth=2)\nplt.xlabel('Incident Angle (degrees)', fontsize=12)\nplt.ylabel('Reflectance', fontsize=12)\nplt.title('Angle-Dependent Reflection of Bragg Mirror')\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.savefig('angle_sweep.png', dpi=150)\nplt.show()\n</code></pre>"},{"location":"quickstart/#common-workflows","title":"Common Workflows","text":""},{"location":"quickstart/#spectral-calculation","title":"Spectral Calculation","text":"<pre><code>wavelengths = np.linspace(0.4, 0.8, 100)  # \u03bcm\nfreqs = 1.0 / wavelengths\n\nR_spectrum = []\nT_spectrum = []\n\nfor freq in freqs:\n    obj = grcwa.obj(nG, L1, L2, freq, theta, phi, verbose=0)\n    # ... add layers ...\n    obj.Init_Setup()\n    # ... setup excitation and pattern ...\n    R, T = obj.RT_Solve(normalize=1)\n    R_spectrum.append(R)\n    T_spectrum.append(T)\n\n# Plot spectrum\nplt.plot(wavelengths, R_spectrum, label='R')\nplt.plot(wavelengths, T_spectrum, label='T')\nplt.xlabel('Wavelength (\u03bcm)')\nplt.ylabel('Power')\nplt.legend()\n</code></pre>"},{"location":"quickstart/#field-visualization","title":"Field Visualization","text":"<pre><code># After solving for R, T\nlayer = 1  # Which layer to visualize\nz_offset = 0.5  # Position within layer\nNxy = [100, 100]  # Grid resolution\n\n# Get fields on grid\n[Ex, Ey, Ez], [Hx, Hy, Hz] = obj.Solve_FieldOnGrid(layer, z_offset, Nxy)\n\n# Compute intensity\nI = np.abs(Ex)**2 + np.abs(Ey)**2 + np.abs(Ez)**2\n\n# Plot\nplt.figure(figsize=(8, 8))\nplt.imshow(I.T, origin='lower', cmap='hot', extent=[0, L1[0], 0, L2[1]])\nplt.colorbar(label='Intensity |E|\u00b2')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.title(f'Field Intensity in Layer {layer}')\nplt.show()\n</code></pre>"},{"location":"quickstart/#quick-reference","title":"Quick Reference","text":""},{"location":"quickstart/#layer-types","title":"Layer Types","text":"Method Use Case <code>Add_LayerUniform(thickness, \u03b5)</code> Homogeneous dielectric <code>Add_LayerGrid(thickness, Nx, Ny)</code> Arbitrary 2D pattern <code>Add_LayerFourier(thickness, params)</code> Analytical Fourier series"},{"location":"quickstart/#solving-options","title":"Solving Options","text":"<pre><code># Total R, T\nR, T = obj.RT_Solve(normalize=1)\n\n# By diffraction order\nRi, Ti = obj.RT_Solve(normalize=1, byorder=1)\n\n# Fields in Fourier space\n[Ex, Ey, Ez], [Hx, Hy, Hz] = obj.Solve_FieldFourier(layer, z_offset)\n\n# Fields in real space\n[Ex, Ey, Ez], [Hx, Hy, Hz] = obj.Solve_FieldOnGrid(layer, z_offset, [Nx, Ny])\n</code></pre>"},{"location":"quickstart/#polarization","title":"Polarization","text":"<p>P-polarization (TM): Electric field in plane of incidence <pre><code>obj.MakeExcitationPlanewave(p_amp=1, p_phase=0, s_amp=0, s_phase=0, order=0)\n</code></pre></p> <p>S-polarization (TE): Electric field perpendicular to plane of incidence <pre><code>obj.MakeExcitationPlanewave(p_amp=0, p_phase=0, s_amp=1, s_phase=0, order=0)\n</code></pre></p> <p>Circular polarization: <pre><code># Left circular\nobj.MakeExcitationPlanewave(p_amp=1, p_phase=0, s_amp=1, s_phase=np.pi/2, order=0)\n\n# Right circular\nobj.MakeExcitationPlanewave(p_amp=1, p_phase=0, s_amp=1, s_phase=-np.pi/2, order=0)\n</code></pre></p>"},{"location":"quickstart/#tips-for-beginners","title":"Tips for Beginners","text":"<ol> <li>Start simple: Begin with uniform layers before trying patterned structures</li> <li>Check energy conservation: <code>R + T</code> should equal 1.0 for lossless materials</li> <li>Use enough harmonics: For patterned layers, <code>nG=101-301</code> typical</li> <li>Grid resolution: Use <code>Nx, Ny \u2265 200</code> for accurate patterns</li> <li>Avoid singularities: For perfect normal incidence with no absorption, add tiny loss</li> <li>Normalize: Always use <code>normalize=1</code> for physically meaningful R, T</li> </ol>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<p>You're now ready to explore more advanced features:</p> <ul> <li>Basic Concepts: Understand RCWA theory in depth</li> <li>Tutorials: Step-by-step guided examples</li> <li>Examples: Browse the example gallery</li> <li>API Reference: Detailed function documentation</li> </ul>"},{"location":"quickstart/#need-help","title":"Need Help?","text":"<ul> <li>Check the FAQ</li> <li>Read Troubleshooting</li> <li>See full examples</li> </ul>"},{"location":"api/core/","title":"Core API Reference","text":"<p>This page documents the core <code>grcwa.obj</code> class and its methods.</p>"},{"location":"api/core/#class-grcwaobj","title":"Class: <code>grcwa.obj</code>","text":"<p>The main class for RCWA simulations.</p>"},{"location":"api/core/#constructor","title":"Constructor","text":"<pre><code>grcwa.obj(nG, L1, L2, freq, theta, phi, verbose=1)\n</code></pre> <p>Creates an RCWA simulation object for a periodic photonic structure.</p> <p>Parameters:</p> <ul> <li> <p>nG (<code>int</code>): Target truncation order for Fourier expansion</p> <ul> <li>Actual <code>nG</code> may be adjusted based on truncation scheme</li> <li>Typical values: 51-301</li> <li>Higher = more accurate but slower</li> </ul> </li> <li> <p>L1 (<code>list[float, float]</code>): First lattice vector <code>[Lx1, Ly1]</code></p> <ul> <li>Defines periodicity in first direction</li> <li>Units: your chosen length unit (\u03bcm, nm, etc.)</li> <li>Example: <code>[1.0, 0]</code> for x-direction period of 1.0</li> </ul> </li> <li> <p>L2 (<code>list[float, float]</code>): Second lattice vector <code>[Lx2, Ly2]</code></p> <ul> <li>Defines periodicity in second direction</li> <li>Need not be orthogonal to L1</li> <li>Example: <code>[0, 1.0]</code> for square lattice</li> </ul> </li> <li> <p>freq (<code>float</code>): Operating frequency</p> <ul> <li>In natural units: \\(f = 1/\\lambda\\)</li> <li>Units: 1/(length unit)</li> <li>Example: <code>freq=1.0</code> means \\(\\lambda=1.0\\) in your units</li> </ul> </li> <li> <p>theta (<code>float</code>): Polar incident angle (radians)</p> <ul> <li>Angle from z-axis (surface normal)</li> <li>Range: \\([0, \\pi/2]\\) typically</li> <li>Normal incidence: <code>theta=0</code></li> </ul> </li> <li> <p>phi (<code>float</code>): Azimuthal incident angle (radians)</p> <ul> <li>Angle in xy-plane from x-axis</li> <li>Range: \\([0, 2\\pi]\\)</li> <li>For normal incidence, arbitrary</li> </ul> </li> <li> <p>verbose (<code>int</code>, optional): Verbosity level, default=1</p> <ul> <li><code>0</code>: Silent</li> <li><code>1</code>: Normal output</li> <li><code>2</code>: Debug information</li> </ul> </li> </ul> <p>Attributes:</p> <p>After initialization:</p> <ul> <li><code>obj.nG</code> (<code>int</code>): Actual truncation order used</li> <li><code>obj.omega</code> (<code>complex</code>): Angular frequency \\(2\\pi f\\)</li> <li><code>obj.Layer_N</code> (<code>int</code>): Total number of layers (after adding)</li> <li><code>obj.G</code> (<code>ndarray</code>): Reciprocal lattice indices <code>(nG, 2)</code></li> <li><code>obj.kx</code> (<code>ndarray</code>): x-components of wave vectors <code>(nG,)</code></li> <li><code>obj.ky</code> (<code>ndarray</code>): y-components of wave vectors <code>(nG,)</code></li> </ul> <p>Example:</p> <pre><code>import grcwa\nimport numpy as np\n\n# Square lattice, wavelength=1.5, normal incidence\nobj = grcwa.obj(nG=101,\n                L1=[1.5, 0],\n                L2=[0, 1.5],\n                freq=1.0/1.5,  # \u03bb=1.5\n                theta=0,\n                phi=0,\n                verbose=1)\n\nprint(f\"Actual nG: {obj.nG}\")\nprint(f\"Angular frequency: {obj.omega}\")\n</code></pre>"},{"location":"api/core/#layer-methods","title":"Layer Methods","text":""},{"location":"api/core/#add_layeruniform","title":"<code>Add_LayerUniform()</code>","text":"<p>Add a uniform (homogeneous) dielectric layer.</p> <pre><code>obj.Add_LayerUniform(thickness, epsilon)\n</code></pre> <p>Parameters:</p> <ul> <li> <p>thickness (<code>float</code>): Layer thickness in length units</p> <ul> <li>Must be positive</li> <li>Can be very large for semi-infinite approximation</li> </ul> </li> <li> <p>epsilon (<code>float</code> or <code>complex</code>): Relative permittivity \\(\\varepsilon_r\\)</p> <ul> <li>Real: lossless dielectric</li> <li>Complex: lossy/absorbing medium</li> <li>For metals, use complex permittivity or Drude model</li> <li>Example: Silicon \\(\\varepsilon = 12.1\\), \\(n = 3.48\\)</li> </ul> </li> </ul> <p>Returns: None</p> <p>Example:</p> <pre><code># Vacuum layer\nobj.Add_LayerUniform(1.0, 1.0)\n\n# Silicon layer (n=3.48, \u03b5=n\u00b2=12.1)\nobj.Add_LayerUniform(0.5, 12.1)\n\n# Lossy dielectric\nobj.Add_LayerUniform(0.3, 4.0 + 0.1j)\n\n# Metal (Drude model)\neps_inf = 1.0\nomega_p = 9.0\ngamma = 0.05\neps_metal = eps_inf - omega_p**2 / (obj.omega**2 + 1j*obj.omega*gamma)\nobj.Add_LayerUniform(0.05, eps_metal)\n</code></pre>"},{"location":"api/core/#add_layergrid","title":"<code>Add_LayerGrid()</code>","text":"<p>Add a patterned layer defined on a Cartesian grid.</p> <pre><code>obj.Add_LayerGrid(thickness, Nx, Ny)\n</code></pre> <p>Parameters:</p> <ul> <li>thickness (<code>float</code>): Layer thickness</li> <li>Nx (<code>int</code>): Number of grid points in x-direction<ul> <li>Typical: 100-500</li> <li>Higher = more accurate pattern representation</li> </ul> </li> <li>Ny (<code>int</code>): Number of grid points in y-direction</li> </ul> <p>Returns: None</p> <p>Notes:</p> <ul> <li>Pattern must be provided later using <code>GridLayer_geteps()</code></li> <li>Grid covers one unit cell: \\(x, y \\in [0, 1]\\) (normalized)</li> <li>Higher resolution better for sharp features</li> <li>Computation time scales with <code>Nx*Ny</code> for FFT</li> </ul> <p>Example:</p> <pre><code># Add patterned layer with 400x400 grid\nobj.Add_LayerGrid(thickness=0.3, Nx=400, Ny=400)\n</code></pre> <p>Later, after all layers added:</p> <pre><code># Create pattern\nNx, Ny = 400, 400\nx = np.linspace(0, 1, Nx)\ny = np.linspace(0, 1, Ny)\nX, Y = np.meshgrid(x, y, indexing='ij')\n\n# Silicon with circular air hole\neps = np.ones((Nx, Ny)) * 12.1\nhole = (X-0.5)**2 + (Y-0.5)**2 &lt; 0.4**2\neps[hole] = 1.0\n\n# Input pattern\nobj.GridLayer_geteps(eps.flatten())\n</code></pre>"},{"location":"api/core/#add_layerfourier","title":"<code>Add_LayerFourier()</code>","text":"<p>Add a patterned layer defined by analytical Fourier coefficients.</p> <pre><code>obj.Add_LayerFourier(thickness, params)\n</code></pre> <p>Parameters:</p> <ul> <li>thickness (<code>float</code>): Layer thickness</li> <li>params: Parameters defining Fourier series<ul> <li>Format depends on implementation</li> <li>Used for shapes with known Fourier series (circles, rectangles)</li> </ul> </li> </ul> <p>Returns: None</p> <p>Note: This method is available but not commonly used. Grid method is more flexible.</p>"},{"location":"api/core/#initialization-method","title":"Initialization Method","text":""},{"location":"api/core/#init_setup","title":"<code>Init_Setup()</code>","text":"<p>Initialize reciprocal lattice and compute eigenvalues for uniform layers.</p> <pre><code>obj.Init_Setup(Pscale=1.0, Gmethod=0)\n</code></pre> <p>Parameters:</p> <ul> <li> <p>Pscale (<code>float</code>, optional): Period scaling factor, default=1.0</p> <ul> <li>Scales lattice vectors: \\(\\mathbf{L}_i \\to P_{\\text{scale}} \\cdot \\mathbf{L}_i\\)</li> <li>Useful for period sweeps with autograd</li> </ul> </li> <li> <p>Gmethod (<code>int</code>, optional): Truncation scheme, default=0</p> <ul> <li><code>0</code>: Circular truncation (isotropic)</li> <li><code>1</code>: Rectangular/parallelogramic truncation</li> </ul> </li> </ul> <p>Returns: None</p> <p>What it does:</p> <ol> <li>Computes reciprocal lattice vectors \\(\\mathbf{K}_1, \\mathbf{K}_2\\)</li> <li>Generates set of reciprocal lattice points \\(\\mathbf{G}_{mn}\\)</li> <li>Computes wave vectors \\(\\mathbf{k}_{mn}\\) for all diffraction orders</li> <li>Solves eigenvalue problems for uniform layers</li> </ol> <p>Must be called before:</p> <ul> <li><code>GridLayer_geteps()</code></li> <li><code>MakeExcitationPlanewave()</code></li> <li><code>RT_Solve()</code></li> </ul> <p>Example:</p> <pre><code>obj.Add_LayerUniform(1.0, 1.0)\nobj.Add_LayerGrid(0.5, 200, 200)\nobj.Add_LayerUniform(1.0, 1.0)\n\n# Initialize with circular truncation\nobj.Init_Setup(Gmethod=0)\n\nprint(f\"Reciprocal vectors: K1={obj.Lk1}, K2={obj.Lk2}\")\nprint(f\"Number of orders: {obj.nG}\")\n</code></pre>"},{"location":"api/core/#pattern-input-method","title":"Pattern Input Method","text":""},{"location":"api/core/#gridlayer_geteps","title":"<code>GridLayer_geteps()</code>","text":"<p>Input dielectric pattern(s) for grid-based patterned layer(s).</p> <pre><code>obj.GridLayer_geteps(ep_all)\n</code></pre> <p>Parameters:</p> <ul> <li>ep_all (<code>ndarray</code>): Flattened array of dielectric constants<ul> <li>For 1 patterned layer: shape <code>(Nx*Ny,)</code></li> <li>For N patterned layers: shape <code>(Nx1*Ny1 + Nx2*Ny2 + ... + NxN*NyN,)</code></li> <li>Must be flattened in C-order (row-major)</li> <li>Can be real or complex</li> </ul> </li> </ul> <p>Returns: None</p> <p>Example (single layer):</p> <pre><code>obj.Add_LayerGrid(0.3, 100, 100)\nobj.Init_Setup()\n\n# Create pattern\neps_grid = np.ones((100, 100)) * 4.0\n# ... modify eps_grid ...\n\n# Input pattern\nobj.GridLayer_geteps(eps_grid.flatten())\n</code></pre> <p>Example (multiple layers):</p> <pre><code>obj.Add_LayerGrid(0.3, 100, 100)  # Layer 1\nobj.Add_LayerGrid(0.4, 150, 150)  # Layer 2\nobj.Init_Setup()\n\neps1 = np.ones((100, 100)) * 4.0\neps2 = np.ones((150, 150)) * 6.0\n# ... modify patterns ...\n\n# Concatenate and input\neps_all = np.concatenate([eps1.flatten(), eps2.flatten()])\nobj.GridLayer_geteps(eps_all)\n</code></pre>"},{"location":"api/core/#excitation-method","title":"Excitation Method","text":""},{"location":"api/core/#makeexcitationplanewave","title":"<code>MakeExcitationPlanewave()</code>","text":"<p>Define plane wave excitation.</p> <pre><code>obj.MakeExcitationPlanewave(p_amp, p_phase, s_amp, s_phase, order=0, direction=0)\n</code></pre> <p>Parameters:</p> <ul> <li> <p>p_amp (<code>float</code>): P-polarization amplitude</p> <ul> <li>P = TM = electric field in plane of incidence</li> <li>Typically 0 or 1</li> </ul> </li> <li> <p>p_phase (<code>float</code>): P-polarization phase (radians)</p> <ul> <li>Usually 0</li> </ul> </li> <li> <p>s_amp (<code>float</code>): S-polarization amplitude</p> <ul> <li>S = TE = electric field perpendicular to plane of incidence</li> <li>Typically 0 or 1</li> </ul> </li> <li> <p>s_phase (<code>float</code>): S-polarization phase (radians)</p> <ul> <li>Use \u00b1\u03c0/2 for circular polarization</li> </ul> </li> <li> <p>order (<code>int</code>, optional): Diffraction order index, default=0</p> <ul> <li>Usually 0 (normal plane wave incidence)</li> <li>For oblique incidence from specific order: use other values</li> </ul> </li> <li> <p>direction (<code>int</code>, optional): Incidence direction, default=0</p> <ul> <li><code>0</code>: Incident from top (input region)</li> <li><code>1</code>: Incident from bottom (output region)</li> </ul> </li> </ul> <p>Returns: None</p> <p>Common polarizations:</p> <pre><code># P-polarized\nobj.MakeExcitationPlanewave(p_amp=1, p_phase=0,\n                             s_amp=0, s_phase=0, order=0)\n\n# S-polarized\nobj.MakeExcitationPlanewave(p_amp=0, p_phase=0,\n                             s_amp=1, s_phase=0, order=0)\n\n# 45\u00b0 linear polarization\nobj.MakeExcitationPlanewave(p_amp=1, p_phase=0,\n                             s_amp=1, s_phase=0, order=0)\n\n# Left circular polarization (LCP)\nobj.MakeExcitationPlanewave(p_amp=1, p_phase=0,\n                             s_amp=1, s_phase=np.pi/2, order=0)\n\n# Right circular polarization (RCP)\nobj.MakeExcitationPlanewave(p_amp=1, p_phase=0,\n                             s_amp=1, s_phase=-np.pi/2, order=0)\n</code></pre>"},{"location":"api/core/#solver-methods","title":"Solver Methods","text":""},{"location":"api/core/#rt_solve","title":"<code>RT_Solve()</code>","text":"<p>Compute reflection and transmission.</p> <pre><code>R, T = obj.RT_Solve(normalize=0, byorder=0)\n</code></pre> <p>Parameters:</p> <ul> <li> <p>normalize (<code>int</code>, optional): Normalization mode, default=0</p> <ul> <li><code>0</code>: Raw power (not normalized)</li> <li><code>1</code>: Normalized by incident power and medium properties</li> </ul> </li> <li> <p>byorder (<code>int</code>, optional): Output mode, default=0</p> <ul> <li><code>0</code>: Total R and T (scalars)</li> <li><code>1</code>: Per-order R and T (arrays of length <code>nG</code>)</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li>If <code>byorder=0</code>: <code>(R, T)</code> where R, T are floats</li> <li>If <code>byorder=1</code>: <code>(Ri, Ti)</code> where Ri, Ti are arrays of length <code>nG</code></li> </ul> <p>Notes:</p> <ul> <li>Use <code>normalize=1</code> for physically meaningful results</li> <li>For lossless structures: \\(R + T = 1\\) (energy conservation)</li> <li>For lossy structures: \\(R + T &lt; 1\\) (absorption)</li> </ul> <p>Example:</p> <pre><code># Total reflection and transmission\nR, T = obj.RT_Solve(normalize=1)\nprint(f\"R = {R:.4f}, T = {T:.4f}, R+T = {R+T:.4f}\")\n\n# By diffraction order\nRi, Ti = obj.RT_Solve(normalize=1, byorder=1)\nprint(f\"0th order reflection: {Ri[0]:.4f}\")\nprint(f\"0th order transmission: {Ti[0]:.4f}\")\nprint(f\"Higher orders: {sum(Ri[1:]) + sum(Ti[1:]):.4f}\")\n\n# Check which orders propagate\nfor i in range(obj.nG):\n    if Ri[i] &gt; 1e-6 or Ti[i] &gt; 1e-6:\n        m, n = obj.G[i]\n        print(f\"Order ({m:2d},{n:2d}): R={Ri[i]:.4f}, T={Ti[i]:.4f}\")\n</code></pre>"},{"location":"api/core/#field-methods","title":"Field Methods","text":"<p>See Field Methods for detailed documentation of:</p> <ul> <li><code>GetAmplitudes()</code>: Get mode amplitudes</li> <li><code>Solve_FieldFourier()</code>: Compute fields in Fourier space</li> <li><code>Solve_FieldOnGrid()</code>: Compute fields in real space</li> <li><code>Volume_integral()</code>: Compute volume integrals</li> <li><code>Solve_ZStressTensorIntegral()</code>: Compute Maxwell stress tensor</li> </ul>"},{"location":"api/core/#utility-methods","title":"Utility Methods","text":""},{"location":"api/core/#return_eps","title":"<code>Return_eps()</code>","text":"<p>Reconstruct dielectric profile from Fourier series.</p> <pre><code>eps_recon = obj.Return_eps(which_layer, Nx, Ny, component=0)\n</code></pre> <p>Parameters:</p> <ul> <li>which_layer (<code>int</code>): Layer index</li> <li>Nx, Ny (<code>int</code>): Grid size for reconstruction</li> <li>component (<code>int</code>, optional): Tensor component, default=0<ul> <li><code>0</code>: \u03b5xx (or scalar \u03b5)</li> <li><code>1</code>: \u03b5yy</li> <li><code>2</code>: \u03b5zz</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li>eps_recon (<code>ndarray</code>): Reconstructed \u03b5, shape <code>(Nx, Ny)</code></li> </ul> <p>Example:</p> <pre><code># Reconstruct pattern in layer 1\neps_recon = obj.Return_eps(which_layer=1, Nx=200, Ny=200)\n\nimport matplotlib.pyplot as plt\nplt.imshow(eps_recon.T, origin='lower')\nplt.colorbar(label='\u03b5')\nplt.title('Reconstructed Dielectric Pattern')\nplt.show()\n</code></pre>"},{"location":"api/core/#backend-configuration","title":"Backend Configuration","text":""},{"location":"api/core/#set_backend","title":"<code>set_backend()</code>","text":"<p>Switch computational backend.</p> <pre><code>grcwa.set_backend(backend_name)\n</code></pre> <p>Parameters:</p> <ul> <li>backend_name (<code>str</code>): Backend to use<ul> <li><code>'numpy'</code>: Standard NumPy (faster, no gradients)</li> <li><code>'autograd'</code>: Autograd-compatible (slower, supports gradients)</li> </ul> </li> </ul> <p>Example:</p> <pre><code>import grcwa\n\n# Use autograd for optimization\ngrcwa.set_backend('autograd')\nimport autograd.numpy as np\nfrom autograd import grad\n\n# Define objective\ndef objective(epsilon):\n    obj = grcwa.obj(...)\n    # ... setup ...\n    obj.GridLayer_geteps(epsilon.flatten())\n    R, T = obj.RT_Solve(normalize=1)\n    return -R  # Maximize reflection\n\n# Compute gradient\ngrad_obj = grad(objective)\n</code></pre> <p>Note: Backend must be set before importing grcwa in the same script, or use <code>importlib.reload()</code>.</p>"},{"location":"api/core/#complete-example","title":"Complete Example","text":"<pre><code>import grcwa\nimport numpy as np\n\n# Setup\nL1 = [1.0, 0]\nL2 = [0, 1.0]\nfreq = 1.0\nnG = 101\n\nobj = grcwa.obj(nG, L1, L2, freq, theta=0, phi=0, verbose=1)\n\n# Add layers\nobj.Add_LayerUniform(1.0, 1.0)        # vacuum\nobj.Add_LayerGrid(0.3, 200, 200)      # patterned\nobj.Add_LayerUniform(1.0, 1.0)        # vacuum\n\n# Initialize\nobj.Init_Setup()\n\n# Create pattern\nNx, Ny = 200, 200\nx = np.linspace(0, 1, Nx)\ny = np.linspace(0, 1, Ny)\nX, Y = np.meshgrid(x, y, indexing='ij')\n\neps = np.ones((Nx, Ny)) * 12.0\nhole = (X-0.5)**2 + (Y-0.5)**2 &lt; 0.3**2\neps[hole] = 1.0\n\nobj.GridLayer_geteps(eps.flatten())\n\n# Excitation\nobj.MakeExcitationPlanewave(p_amp=1, p_phase=0,\n                             s_amp=0, s_phase=0, order=0)\n\n# Solve\nR, T = obj.RT_Solve(normalize=1)\nprint(f\"R = {R:.4f}, T = {T:.4f}, R+T = {R+T:.4f}\")\n\n# Get fields\n[Ex, Ey, Ez], [Hx, Hy, Hz] = obj.Solve_FieldOnGrid(1, 0.15, [100, 100])\nI = np.abs(Ex)**2 + np.abs(Ey)**2 + np.abs(Ez)**2\n\n# Plot\nimport matplotlib.pyplot as plt\nplt.imshow(I.T, origin='lower', cmap='hot')\nplt.colorbar(label='Intensity')\nplt.title('Field Intensity in Patterned Layer')\nplt.show()\n</code></pre>"},{"location":"api/core/#see-also","title":"See Also","text":"<ul> <li>Layer Methods: Detailed layer management</li> <li>Solver Methods: Advanced solving options</li> <li>Field Methods: Field analysis and visualization</li> <li>Tutorials: Step-by-step examples</li> </ul>"},{"location":"examples/gallery/","title":"Example Gallery","text":"<p>Browse examples of RCWA simulations with GRCWA.</p>"},{"location":"examples/gallery/#basic-examples","title":"Basic Examples","text":""},{"location":"examples/gallery/#example-1-square-lattice-with-circular-holes","title":"Example 1: Square Lattice with Circular Holes","text":"<p>Compute transmission and reflection through a photonic crystal slab with circular air holes in a square lattice.</p> <p>Structure:</p> <ul> <li>Square lattice: period = 1.5 \u03bcm</li> <li>Silicon slab (\u03b5=4) with circular air holes</li> <li>Hole radius: 0.3 \u00d7 period</li> <li>Slab thickness: 0.2 \u03bcm</li> </ul> <p>Code: ex1.py</p> <p>Results:</p> <ul> <li>Total and per-order reflection/transmission</li> <li>Demonstrates diffraction into multiple orders</li> </ul>"},{"location":"examples/gallery/#example-2-two-patterned-layers","title":"Example 2: Two Patterned Layers","text":"<p>Multi-layer structure with two different patterned layers.</p> <p>Structure:</p> <ul> <li>Layer 1: Circular holes (\u03b5=4)</li> <li>Layer 2: Square holes (\u03b5=6)</li> <li>Different patterns in each layer</li> </ul> <p>Code: ex2.py</p> <p>Results:</p> <ul> <li>Shows how to handle multiple patterned layers</li> <li>Oblique incidence (\u03b8 = \u03c0/10)</li> </ul>"},{"location":"examples/gallery/#example-3-topology-optimization","title":"Example 3: Topology Optimization","text":"<p>Inverse design using automatic differentiation.</p> <p>Objective: Maximize reflection from a single patterned layer</p> <p>Method:</p> <ul> <li>Autograd for gradients</li> <li>NLOPT for optimization</li> <li>Gradient-based topology optimization</li> </ul> <p>Code: ex3.py</p> <p>Results:</p> <ul> <li>Optimized dielectric pattern</li> <li>Convergence of reflection vs. iteration</li> </ul>"},{"location":"examples/gallery/#example-4-hexagonal-lattice","title":"Example 4: Hexagonal Lattice","text":"<p>Hexagonal lattice of circular holes.</p> <p>Structure:</p> <ul> <li>Hexagonal lattice (60\u00b0 angle)</li> <li>Circular air holes</li> <li>High grid resolution (1000\u00d71000)</li> </ul> <p>Code: ex4.py</p> <p>Results:</p> <ul> <li>Demonstrates non-orthogonal lattices</li> <li>Proper coordinate transformation for hexagonal symmetry</li> </ul>"},{"location":"examples/gallery/#advanced-examples","title":"Advanced Examples","text":""},{"location":"examples/gallery/#bragg-mirror","title":"Bragg Mirror","text":"<p>Multi-layer Bragg reflector (1D photonic crystal).</p> <pre><code>import grcwa\nimport numpy as np\n\n# Parameters\nwavelength = 1.0\nfreq = 1.0 / wavelength\nn1, n2 = 2.0, 1.5  # High/low index\nd1 = wavelength / (4*n1)  # Quarter-wave thickness\nd2 = wavelength / (4*n2)\nN_pairs = 10  # Number of layer pairs\n\n# Setup\nobj = grcwa.obj(51, [1,0], [0,1], freq, 0, 0, verbose=0)\n\n# Add layers\nfor i in range(N_pairs):\n    obj.Add_LayerUniform(d1, n1**2)\n    obj.Add_LayerUniform(d2, n2**2)\n\nobj.Init_Setup()\nobj.MakeExcitationPlanewave(1, 0, 0, 0, 0)\nR, T = obj.RT_Solve(normalize=1)\n\nprint(f\"Bragg Mirror: R={R:.4f}, T={T:.4f}\")\n</code></pre> <p>Result: High reflection (~99%) at design wavelength.</p>"},{"location":"examples/gallery/#anti-reflection-coating","title":"Anti-Reflection Coating","text":"<p>Quarter-wave anti-reflection coating.</p> <pre><code># Substrate: n=3.5 (e.g., GaAs)\n# Coating: n=sqrt(3.5) \u2248 1.87 (optimal)\n# Thickness: \u03bb/4n\n\nwavelength = 1.0\nn_substrate = 3.5\nn_coating = np.sqrt(n_substrate)\nthickness = wavelength / (4*n_coating)\n\nobj = grcwa.obj(51, [1,0], [0,1], 1/wavelength, 0, 0, verbose=0)\nobj.Add_LayerUniform(1.0, 1.0)  # Air\nobj.Add_LayerUniform(thickness, n_coating**2)  # AR coating\nobj.Add_LayerUniform(10.0, n_substrate**2)  # Substrate (thick)\n\nobj.Init_Setup()\nobj.MakeExcitationPlanewave(1, 0, 0, 0, 0)\nR, T = obj.RT_Solve(normalize=1)\n\nprint(f\"Without AR coating, R would be: {((1-n_substrate)/(1+n_substrate))**2:.4f}\")\nprint(f\"With AR coating: R={R:.6f}\")\n</code></pre> <p>Result: Nearly zero reflection at design wavelength.</p>"},{"location":"examples/gallery/#metasurface-lens","title":"Metasurface Lens","text":"<p>Phase gradient metasurface for beam steering.</p> <pre><code># Create phase gradient across unit cell\ndef phase_gradient_pattern(Nx, Ny, gradient_angle):\n    x = np.linspace(0, 1, Nx)\n    y = np.linspace(0, 1, Ny)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # Phase = k*x*sin(theta) approximated by varying dielectric\n    # Simplified model: use pillars of varying size\n    phase = 2*np.pi*X*np.tan(gradient_angle)\n    pillar_radius = 0.1 + 0.2 * (phase / (2*np.pi)) % 1\n\n    eps = np.ones((Nx, Ny))\n    for i in range(Nx):\n        for j in range(Ny):\n            if (X[i,j]-0.5)**2 + (Y[i,j]-0.5)**2 &lt; pillar_radius**2:\n                eps[i,j] = 12.0  # Silicon\n\n    return eps\n\n# Simulate\ngradient_angle = 10 * np.pi/180\neps_meta = phase_gradient_pattern(300, 300, gradient_angle)\n\nobj = grcwa.obj(201, [0.6,0], [0,0.6], 1.0, 0, 0, verbose=0)\nobj.Add_LayerUniform(1.0, 1.0)\nobj.Add_LayerGrid(0.5, 300, 300)\nobj.Add_LayerUniform(1.0, 1.0)\nobj.Init_Setup()\nobj.GridLayer_geteps(eps_meta.flatten())\nobj.MakeExcitationPlanewave(1, 0, 0, 0, 0)\n\nRi, Ti = obj.RT_Solve(normalize=1, byorder=1)\n\n# Find dominant diffraction order\nmax_order = np.argmax(Ti)\nprint(f\"Most power in order {obj.G[max_order]}: T={Ti[max_order]:.4f}\")\n</code></pre>"},{"location":"examples/gallery/#photonic-crystal-waveguide","title":"Photonic Crystal Waveguide","text":"<p>Line defect in photonic crystal.</p> <pre><code># Create photonic crystal with line defect\ndef pc_waveguide(Nx, Ny, lattice_const=0.4, hole_radius=0.3):\n    x = np.linspace(0, 1, Nx)\n    y = np.linspace(0, 1, Ny)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    eps = np.ones((Nx, Ny)) * 12.0  # Silicon background\n\n    # Regular array of holes\n    for i in range(-2, 3):\n        for j in range(-2, 3):\n            if j == 0:\n                continue  # Skip middle row (waveguide)\n            cx = 0.5 + i*lattice_const\n            cy = 0.5 + j*lattice_const\n            hole = (X-cx)**2 + (Y-cy)**2 &lt; hole_radius**2\n            eps[hole] = 1.0\n\n    return eps\n\neps_wg = pc_waveguide(400, 400)\n\n# Simulate guided mode at frequency in band gap\nobj = grcwa.obj(201, [2.0,0], [0,2.0], 0.3, 0, 0, verbose=0)\nobj.Add_LayerUniform(1.0, 1.0)\nobj.Add_LayerGrid(1.0, 400, 400)\nobj.Add_LayerUniform(1.0, 1.0)\nobj.Init_Setup()\nobj.GridLayer_geteps(eps_wg.flatten())\nobj.MakeExcitationPlanewave(1, 0, 0, 0, 0)\n\nR, T = obj.RT_Solve(normalize=1)\nprint(f\"Guided mode: R={R:.4f}, T={T:.4f}\")\n</code></pre>"},{"location":"examples/gallery/#grating-coupler","title":"Grating Coupler","text":"<p>Couples normally incident light to in-plane waveguide mode.</p> <pre><code># 1D grating\ndef grating(Nx, Ny, period_frac=0.5, depth_frac=0.3):\n    x = np.linspace(0, 1, Nx)\n    y = np.linspace(0, 1, Ny)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # Background: Silicon\n    eps = np.ones((Nx, Ny)) * 12.0\n\n    # Grating: remove silicon in alternating stripes\n    grating_lines = (X % (1/5)) &lt; (period_frac / 5)\n    eps[grating_lines] = 1.0\n\n    return eps\n\neps_grating = grating(400, 200)\n\nobj = grcwa.obj(201, [0.6,0], [0,0.3], 1.0, 0, 0, verbose=0)\nobj.Add_LayerUniform(1.0, 1.0)\nobj.Add_LayerGrid(0.2, 400, 200)\nobj.Add_LayerUniform(1.0, 12.0)  # Silicon substrate\nobj.Init_Setup()\nobj.GridLayer_geteps(eps_grating.flatten())\nobj.MakeExcitationPlanewave(1, 0, 0, 0, 0)\n\nRi, Ti = obj.RT_Solve(normalize=1, byorder=1)\n\n# Power coupled to different orders\nfor i in range(min(10, obj.nG)):\n    if Ti[i] &gt; 0.01:\n        print(f\"Order {obj.G[i]}: T={Ti[i]:.4f}\")\n</code></pre>"},{"location":"examples/gallery/#spectral-calculations","title":"Spectral Calculations","text":""},{"location":"examples/gallery/#photonic-band-diagram","title":"Photonic Band Diagram","text":"<p>Compute transmission vs. frequency and incident angle.</p> <pre><code>frequencies = np.linspace(0.3, 0.7, 40)\nangles = np.linspace(0, 45, 30) * np.pi/180\n\nT_map = np.zeros((len(frequencies), len(angles)))\n\nfor i, freq in enumerate(frequencies):\n    for j, theta in enumerate(angles):\n        obj = grcwa.obj(101, [1,0], [0,1], freq, theta, 0, verbose=0)\n        obj.Add_LayerUniform(1.0, 1.0)\n        obj.Add_LayerGrid(0.5, 200, 200)\n        obj.Add_LayerUniform(1.0, 1.0)\n        obj.Init_Setup()\n        obj.GridLayer_geteps(eps_pattern.flatten())\n        obj.MakeExcitationPlanewave(1, 0, 0, 0, 0)\n        R, T = obj.RT_Solve(normalize=1)\n        T_map[i,j] = T\n\n# Plot band diagram\nplt.figure(figsize=(8,6))\nplt.pcolormesh(angles*180/np.pi, frequencies, T_map, cmap='hot', shading='auto')\nplt.colorbar(label='Transmission')\nplt.xlabel('Incident Angle (degrees)')\nplt.ylabel('Frequency (c/\u03bb)')\nplt.title('Photonic Band Diagram')\nplt.show()\n</code></pre>"},{"location":"examples/gallery/#visualization-examples","title":"Visualization Examples","text":""},{"location":"examples/gallery/#field-intensity-profile","title":"Field Intensity Profile","text":"<pre><code># After solving\n[Ex, Ey, Ez], [Hx, Hy, Hz] = obj.Solve_FieldOnGrid(1, 0.15, [200, 200])\n\n# Intensity\nI = np.abs(Ex)**2 + np.abs(Ey)**2 + np.abs(Ez)**2\n\n# Plot\nplt.figure(figsize=(8,8))\nplt.imshow(I.T, origin='lower', cmap='hot', extent=[0, L1[0], 0, L2[1]])\nplt.colorbar(label='|E|\u00b2')\nplt.xlabel('x (\u03bcm)')\nplt.ylabel('y (\u03bcm)')\nplt.title('Electric Field Intensity')\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"examples/gallery/#poynting-vector-field","title":"Poynting Vector Field","text":"<pre><code># Compute Poynting vector\nSx = 0.5 * np.real(Ey * np.conj(Hz) - Ez * np.conj(Hy))\nSy = 0.5 * np.real(Ez * np.conj(Hx) - Ex * np.conj(Hz))\nSz = 0.5 * np.real(Ex * np.conj(Hy) - Ey * np.conj(Hx))\n\n# Plot\nplt.figure(figsize=(8,8))\nplt.quiver(Sx[::10,::10], Sy[::10,::10])\nplt.imshow(np.abs(Sz.T), origin='lower', cmap='coolwarm', alpha=0.5)\nplt.colorbar(label='Sz')\nplt.title('Poynting Vector (energy flow)')\nplt.show()\n</code></pre>"},{"location":"examples/gallery/#tips-for-creating-your-own-examples","title":"Tips for Creating Your Own Examples","text":"<ol> <li>Start simple: Begin with uniform layers to verify setup</li> <li>Test convergence: Increase \\(N_G\\) until results stabilize</li> <li>Check energy conservation: \\(R + T = 1\\) for lossless</li> <li>Visualize patterns: Use <code>Return_eps()</code> to verify your pattern</li> <li>Analyze fields: Use <code>Solve_FieldOnGrid()</code> to understand physics</li> <li>Sweep parameters: Vary wavelength, angle, or geometry</li> </ol>"},{"location":"examples/gallery/#see-also","title":"See Also","text":"<ul> <li>Tutorials: Step-by-step guided examples</li> <li>API Reference: Complete function documentation</li> <li>Examples Source Code: Detailed example implementations</li> </ul>"},{"location":"guide/concepts/","title":"Basic Concepts","text":"<p>This guide explains the fundamental concepts needed to use GRCWA effectively.</p>"},{"location":"guide/concepts/#the-rcwa-workflow","title":"The RCWA Workflow","text":"<p>Every RCWA simulation follows these steps:</p> <pre><code>import grcwa\nimport numpy as np\n\n# 1. Create RCWA object\nobj = grcwa.obj(nG, L1, L2, freq, theta, phi)\n\n# 2. Define layer stack\nobj.Add_LayerUniform(thickness1, epsilon1)\nobj.Add_LayerGrid(thickness2, Nx, Ny)\nobj.Add_LayerUniform(thickness3, epsilon3)\n\n# 3. Initialize\nobj.Init_Setup()\n\n# 4. Input patterns (for grid layers)\nobj.GridLayer_geteps(epsilon_grid)\n\n# 5. Define excitation\nobj.MakeExcitationPlanewave(p_amp, p_phase, s_amp, s_phase, order=0)\n\n# 6. Solve\nR, T = obj.RT_Solve(normalize=1)\n\n# 7. Analyze fields (optional)\n[Ex,Ey,Ez], [Hx,Hy,Hz] = obj.Solve_FieldOnGrid(layer, z, [Nx,Ny])\n</code></pre>"},{"location":"guide/concepts/#coordinate-system","title":"Coordinate System","text":"<p>GRCWA uses a right-handed Cartesian coordinate system:</p> <ul> <li>x, y: In-plane directions (periodic)</li> <li>z: Out-of-plane direction (layer stacking)</li> <li>Light propagates in the +z direction</li> </ul> <pre><code>     z \u2191\n       |\n       |  \u250c\u2500\u2500\u2500\u2500\u2500\u2500 Layer N\n       |  \u251c\u2500\u2500\u2500\u2500\u2500\u2500 Layer 2\n       |  \u251c\u2500\u2500\u2500\u2500\u2500\u2500 Layer 1\n       |  \u2514\u2500\u2500\u2500\u2500\u2500\u2500 Layer 0 (input)\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192 x\n      \u2199\n     y\n</code></pre>"},{"location":"guide/concepts/#periodicity-and-lattice-vectors","title":"Periodicity and Lattice Vectors","text":""},{"location":"guide/concepts/#lattice-definition","title":"Lattice Definition","text":"<p>Two lattice vectors \\(\\mathbf{L}_1\\) and \\(\\mathbf{L}_2\\) define the 2D periodic unit cell:</p> \\[ \\mathbf{L}_1 = (L_{1x}, L_{1y}, 0) \\] \\[ \\mathbf{L}_2 = (L_{2x}, L_{2y}, 0) \\] <p>The structure repeats every:</p> \\[ \\mathbf{r} + m\\mathbf{L}_1 + n\\mathbf{L}_2 \\quad (m, n \\in \\mathbb{Z}) \\]"},{"location":"guide/concepts/#common-lattices","title":"Common Lattices","text":"<p>Square lattice (period \\(a\\)): <pre><code>L1 = [a, 0]\nL2 = [0, a]\n</code></pre></p> <p>Rectangular lattice (periods \\(a, b\\)): <pre><code>L1 = [a, 0]\nL2 = [0, b]\n</code></pre></p> <p>Hexagonal lattice (period \\(a\\)): <pre><code>L1 = [a, 0]\nL2 = [a/2, a*np.sqrt(3)/2]\n</code></pre></p>"},{"location":"guide/concepts/#unit-cell-area","title":"Unit Cell Area","text":"<p>The area of the unit cell is:</p> \\[ A_{\\text{cell}} = |\\mathbf{L}_1 \\times \\mathbf{L}_2| = |L_{1x}L_{2y} - L_{1y}L_{2x}| \\]"},{"location":"guide/concepts/#layer-types","title":"Layer Types","text":""},{"location":"guide/concepts/#1-uniform-layers","title":"1. Uniform Layers","text":"<p>Homogeneous dielectric with constant \\(\\varepsilon\\):</p> <pre><code>obj.Add_LayerUniform(thickness, epsilon)\n</code></pre> <p>Advantages:</p> <ul> <li>Very fast (analytical solution)</li> <li>Numerically stable</li> <li>No pattern input needed</li> </ul> <p>Use for:</p> <ul> <li>Vacuum/air regions</li> <li>Solid dielectric slabs</li> <li>Substrate layers</li> <li>Cladding layers</li> </ul>"},{"location":"guide/concepts/#2-grid-based-patterned-layers","title":"2. Grid-Based Patterned Layers","text":"<p>Arbitrary 2D pattern on Cartesian grid:</p> <pre><code>obj.Add_LayerGrid(thickness, Nx, Ny)\n# Later:\nobj.GridLayer_geteps(epsilon_grid.flatten())\n</code></pre> <p>Advantages:</p> <ul> <li>Maximum flexibility (any pattern)</li> <li>Easy to define complex shapes</li> <li>Supports numerical optimization</li> </ul> <p>Use for:</p> <ul> <li>Photonic crystals</li> <li>Metasurfaces</li> <li>Arbitrary patterns</li> <li>Optimization problems</li> </ul> <p>Grid resolution:</p> <ul> <li>Smooth patterns: Nx, Ny \u2248 50-100</li> <li>Sharp features: Nx, Ny \u2248 200-500</li> <li>Very fine details: Nx, Ny \u2248 500-1000</li> </ul>"},{"location":"guide/concepts/#3-fourier-series-layers","title":"3. Fourier Series Layers","text":"<p>Pattern defined by analytical Fourier coefficients:</p> <pre><code>obj.Add_LayerFourier(thickness, params)\n</code></pre> <p>Advantages:</p> <ul> <li>No FFT needed</li> <li>Exact for known geometries (circles, rectangles)</li> </ul> <p>Disadvantages:</p> <ul> <li>Limited to shapes with known Fourier series</li> <li>Rarely used in practice</li> </ul>"},{"location":"guide/concepts/#truncation-order","title":"Truncation Order","text":""},{"location":"guide/concepts/#what-is-it","title":"What is it?","text":"<p>The truncation order \\(N_G\\) determines how many Fourier harmonics (diffraction orders) are included:</p> \\[ \\mathbf{E}(\\mathbf{r}) = \\sum_{m,n} \\mathbf{E}_{mn}(z) e^{i\\mathbf{k}_{mn} \\cdot \\mathbf{r}_\\parallel} \\] <p>The sum is truncated to \\(N_G\\) terms.</p>"},{"location":"guide/concepts/#choosing-n_g","title":"Choosing \\(N_G\\)","text":"<p>Rules of thumb:</p> Structure Type Recommended \\(N_G\\) Uniform layers 11-51 Smooth patterns 51-101 Sharp features 101-301 Very fine details 301-501 High accuracy 501-1001 <p>Trade-offs:</p> <ul> <li>\u2705 Larger \\(N_G\\) \u2192 More accurate</li> <li>\u274c Larger \\(N_G\\) \u2192 Slower computation</li> <li>\u274c Larger \\(N_G\\) \u2192 More memory</li> </ul>"},{"location":"guide/concepts/#convergence-testing","title":"Convergence Testing","text":"<p>Always test convergence:</p> <pre><code>nG_values = [51, 101, 201, 301]\nfor nG in nG_values:\n    obj = grcwa.obj(nG, L1, L2, freq, theta, phi, verbose=0)\n    # ... setup ...\n    R, T = obj.RT_Solve(normalize=1)\n    print(f\"nG={obj.nG:4d}: R={R:.6f}, T={T:.6f}\")\n</code></pre> <p>Converged when results don't change with increasing \\(N_G\\).</p>"},{"location":"guide/concepts/#incident-wave","title":"Incident Wave","text":""},{"location":"guide/concepts/#angles","title":"Angles","text":"<p>Polar angle \\(\\theta\\): Angle from z-axis (surface normal)</p> <ul> <li>\\(\\theta = 0\\): Normal incidence</li> <li>\\(0 &lt; \\theta &lt; 90\u00b0\\): Oblique incidence</li> </ul> <p>Azimuthal angle \\(\\phi\\): Angle in xy-plane from x-axis</p> <ul> <li>Defines the direction of the projection of \\(\\mathbf{k}\\) onto xy-plane</li> </ul> <p>Incident wave vector:</p> \\[ \\mathbf{k}_{\\text{inc}} = \\omega\\sqrt{\\varepsilon_{\\text{in}}}(\\sin\\theta\\cos\\phi, \\sin\\theta\\sin\\phi, \\cos\\theta) \\]"},{"location":"guide/concepts/#polarization","title":"Polarization","text":"<p>P-polarization (TM):</p> <ul> <li>Electric field in the plane of incidence</li> <li>Magnetic field perpendicular to plane of incidence</li> </ul> <p>S-polarization (TE):</p> <ul> <li>Electric field perpendicular to plane of incidence</li> <li>Magnetic field in the plane of incidence</li> </ul> <p>Arbitrary polarization:</p> \\[ \\mathbf{E} = A_p e^{i\\phi_p} \\hat{p} + A_s e^{i\\phi_s} \\hat{s} \\] <p>Common cases:</p> <pre><code># P-polarized\nobj.MakeExcitationPlanewave(1, 0, 0, 0, 0)\n\n# S-polarized\nobj.MakeExcitationPlanewave(0, 0, 1, 0, 0)\n\n# Linear 45\u00b0\nobj.MakeExcitationPlanewave(1, 0, 1, 0, 0)\n\n# Left circular\nobj.MakeExcitationPlanewave(1, 0, 1, np.pi/2, 0)\n\n# Right circular\nobj.MakeExcitationPlanewave(1, 0, 1, -np.pi/2, 0)\n</code></pre>"},{"location":"guide/concepts/#diffraction-orders","title":"Diffraction Orders","text":""},{"location":"guide/concepts/#what-are-they","title":"What are they?","text":"<p>Due to periodicity, the incident wave couples to discrete diffraction orders:</p> \\[ \\mathbf{k}_{mn,\\parallel} = \\mathbf{k}_{\\parallel,0} + m\\mathbf{K}_1 + n\\mathbf{K}_2 \\] <p>Each \\((m,n)\\) is a diffraction order.</p>"},{"location":"guide/concepts/#propagating-vs-evanescent","title":"Propagating vs. Evanescent","text":"<p>For each order, compute:</p> \\[ k_{z,mn} = \\sqrt{\\varepsilon\\omega^2 - k_{x,mn}^2 - k_{y,mn}^2} \\] <ul> <li>Propagating: \\(k_z\\) is real \u2192 carries power to far field</li> <li>Evanescent: \\(k_z\\) is imaginary \u2192 decays exponentially</li> </ul> <p>Example:</p> <pre><code># After Init_Setup()\nfor i in range(obj.nG):\n    kx = obj.kx[i]\n    ky = obj.ky[i]\n    kz_sq = obj.omega**2 - kx**2 - ky**2  # In vacuum\n    if kz_sq &gt; 0:\n        print(f\"Order {obj.G[i]}: propagating, kz={np.sqrt(kz_sq):.4f}\")\n    else:\n        print(f\"Order {obj.G[i]}: evanescent, \u03ba={np.sqrt(-kz_sq):.4f}\")\n</code></pre>"},{"location":"guide/concepts/#reflection-and-transmission","title":"Reflection and Transmission","text":""},{"location":"guide/concepts/#total-power","title":"Total Power","text":"<pre><code>R, T = obj.RT_Solve(normalize=1)\n</code></pre> <ul> <li>\\(R\\): Total reflected power (all orders)</li> <li>\\(T\\): Total transmitted power (all orders)</li> </ul> <p>For lossless structures: \\(R + T = 1\\)</p>"},{"location":"guide/concepts/#by-order","title":"By Order","text":"<pre><code>Ri, Ti = obj.RT_Solve(normalize=1, byorder=1)\n</code></pre> <ul> <li><code>Ri[i]</code>: Reflected power in order \\(i\\)</li> <li><code>Ti[i]</code>: Transmitted power in order \\(i\\)</li> </ul> <p>Analysis:</p> <pre><code>print(f\"0th order: R={Ri[0]:.4f}, T={Ti[0]:.4f}\")\nprint(f\"Higher orders: R={sum(Ri[1:]):.4f}, T={sum(Ti[1:]):.4f}\")\n\n# Which orders carry significant power?\nthreshold = 1e-3\nfor i in range(obj.nG):\n    if Ri[i] &gt; threshold or Ti[i] &gt; threshold:\n        m, n = obj.G[i]\n        print(f\"Order ({m:2d},{n:2d}): R={Ri[i]:.4f}, T={Ti[i]:.4f}\")\n</code></pre>"},{"location":"guide/concepts/#field-analysis","title":"Field Analysis","text":""},{"location":"guide/concepts/#fourier-space","title":"Fourier Space","text":"<p>Get Fourier coefficients:</p> <pre><code>[Ex_mn, Ey_mn, Ez_mn], [Hx_mn, Hy_mn, Hz_mn] = obj.Solve_FieldFourier(layer, z_offset)\n</code></pre> <p>Each array has length <code>nG</code>, complex values.</p>"},{"location":"guide/concepts/#real-space","title":"Real Space","text":"<p>Get fields on a grid:</p> <pre><code>[Ex, Ey, Ez], [Hx, Hy, Hz] = obj.Solve_FieldOnGrid(layer, z_offset, [Nx, Ny])\n</code></pre> <p>Each array has shape <code>(Nx, Ny)</code>, complex values.</p> <p>Intensity:</p> <pre><code>I = np.abs(Ex)**2 + np.abs(Ey)**2 + np.abs(Ez)**2\n</code></pre> <p>Poynting vector:</p> <pre><code>Sx = 0.5 * np.real(Ey * np.conj(Hz) - Ez * np.conj(Hy))\nSy = 0.5 * np.real(Ez * np.conj(Hx) - Ex * np.conj(Hz))\nSz = 0.5 * np.real(Ex * np.conj(Hy) - Ey * np.conj(Hx))\n</code></pre>"},{"location":"guide/concepts/#normalization","title":"Normalization","text":""},{"location":"guide/concepts/#why-normalize","title":"Why normalize?","text":"<p>Raw RCWA outputs are amplitudes. To get physical powers, we must normalize by:</p> <ul> <li>Incident power</li> <li>Medium properties (impedance)</li> <li>Angle (projected area)</li> </ul>"},{"location":"guide/concepts/#normalized-vs-unnormalized","title":"Normalized vs. Unnormalized","text":"<pre><code># Normalized (recommended)\nR, T = obj.RT_Solve(normalize=1)\n# R + T = 1 for lossless\n\n# Unnormalized (raw amplitudes)\nR_raw, T_raw = obj.RT_Solve(normalize=0)\n# Need manual normalization\n</code></pre> <p>Always use <code>normalize=1</code> for physically meaningful results.</p>"},{"location":"guide/concepts/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"guide/concepts/#1-energy-not-conserved","title":"1. Energy Not Conserved","text":"<p>Symptom: \\(R + T \\neq 1\\)</p> <p>Causes:</p> <ul> <li>Insufficient \\(N_G\\) (increase truncation order)</li> <li>Numerical instability (reduce layer thickness or \\(N_G\\))</li> <li>Very high contrast structures (use more grid points)</li> </ul>"},{"location":"guide/concepts/#2-wrong-units","title":"2. Wrong Units","text":"<p>Symptom: Strange results, unphysical values</p> <p>Solution: Ensure consistent units:</p> <pre><code># All in \u03bcm\nwavelength = 1.5  # \u03bcm\nfreq = 1.0 / wavelength\nL1 = [0.6, 0]  # \u03bcm\nthickness = 0.3  # \u03bcm\n</code></pre>"},{"location":"guide/concepts/#3-grid-resolution-too-low","title":"3. Grid Resolution Too Low","text":"<p>Symptom: Incorrect patterns, jagged edges</p> <p>Solution: Increase <code>Nx, Ny</code>:</p> <pre><code># Low resolution (bad)\nobj.Add_LayerGrid(0.3, 50, 50)\n\n# High resolution (good)\nobj.Add_LayerGrid(0.3, 400, 400)\n</code></pre>"},{"location":"guide/concepts/#4-pattern-coordinates","title":"4. Pattern Coordinates","text":"<p>Mistake: Confusing normalized and physical coordinates</p> <p>Correct:</p> <pre><code># Pattern defined on [0,1] \u00d7 [0,1] (normalized)\nx = np.linspace(0, 1, Nx)\ny = np.linspace(0, 1, Ny)\nX, Y = np.meshgrid(x, y, indexing='ij')\n\n# Physical coordinates: multiply by lattice vectors\nx_phys = X * L1[0] + Y * L2[0]\ny_phys = X * L1[1] + Y * L2[1]\n</code></pre>"},{"location":"guide/concepts/#5-singular-matrix","title":"5. Singular Matrix","text":"<p>Symptom: Error in eigenvalue solving</p> <p>Causes:</p> <ul> <li>Perfect normal incidence with no loss</li> <li>Degenerate geometry</li> </ul> <p>Solution: Add tiny loss:</p> <pre><code># Instead of freq = 1.0\nQabs = 1e8  # Very high Q\nfreq = 1.0 * (1 + 1j / (2*Qabs))\n</code></pre>"},{"location":"guide/concepts/#best-practices","title":"Best Practices","text":""},{"location":"guide/concepts/#do","title":"\u2705 Do","text":"<ul> <li>Test convergence with increasing \\(N_G\\)</li> <li>Use <code>normalize=1</code> for R, T</li> <li>Verify \\(R + T = 1\\) for lossless structures</li> <li>Use sufficient grid resolution (\\(N_x, N_y \\geq 200\\))</li> <li>Check energy conservation</li> </ul>"},{"location":"guide/concepts/#dont","title":"\u274c Don't","text":"<ul> <li>Use too few harmonics (risk unconverged results)</li> <li>Forget to call <code>Init_Setup()</code> before solving</li> <li>Mix units (e.g., \u03bcm for length, nm for wavelength)</li> <li>Use extremely thick layers (numerical instability)</li> <li>Ignore energy conservation errors</li> </ul>"},{"location":"guide/concepts/#summary","title":"Summary","text":"<p>Key concepts for GRCWA:</p> <ol> <li>Workflow: Create \u2192 Add layers \u2192 Initialize \u2192 Input patterns \u2192 Excite \u2192 Solve</li> <li>Lattice: Defined by \\(\\mathbf{L}_1, \\mathbf{L}_2\\)</li> <li>Truncation: \\(N_G\\) harmonics, test convergence</li> <li>Layers: Uniform (fast) or grid-based (flexible)</li> <li>Excitation: Angles \\((\\theta, \\phi)\\) and polarization \\((p, s)\\)</li> <li>Results: \\(R, T\\) total or by order</li> <li>Fields: Fourier or real space</li> </ol>"},{"location":"guide/concepts/#next-steps","title":"Next Steps","text":"<ul> <li>Layer Definition: Detailed layer management</li> <li>Excitation Setup: Polarization and angles</li> <li>Computing Results: Interpreting R, T, and fields</li> <li>Tutorials: Hands-on examples</li> </ul>"},{"location":"reference/faq/","title":"Frequently Asked Questions (FAQ)","text":""},{"location":"reference/faq/#general-questions","title":"General Questions","text":""},{"location":"reference/faq/#what-is-rcwa","title":"What is RCWA?","text":"<p>Rigorous Coupled Wave Analysis (RCWA) is a semi-analytical method for solving Maxwell's equations in periodic structures. It expands electromagnetic fields in Fourier series and solves the resulting eigenvalue problems layer by layer. RCWA is exact (within numerical precision) and particularly efficient for periodic photonic structures.</p>"},{"location":"reference/faq/#when-should-i-use-rcwa-instead-of-fdtd-or-fem","title":"When should I use RCWA instead of FDTD or FEM?","text":"<p>Use RCWA when:</p> <ul> <li>Your structure has 2D periodicity (photonic crystals, gratings, metasurfaces)</li> <li>You need spectral or angular response (frequency/angle sweeps)</li> <li>You want fast simulations of periodic structures</li> <li>You need far-field diffraction patterns</li> </ul> <p>Use FDTD/FEM when:</p> <ul> <li>Structure is aperiodic (isolated objects, random structures)</li> <li>You need time-domain response</li> <li>3D arbitrary geometries without periodicity</li> <li>Broadband simulations in single run (FDTD advantage)</li> </ul>"},{"location":"reference/faq/#what-does-autogradable-mean","title":"What does \"autoGradable\" mean?","text":"<p>GRCWA integrates with Autograd, enabling automatic differentiation. This means you can compute gradients of any output (R, T, fields) with respect to any input (\u03b5, frequency, angles, thickness) automatically, without deriving adjoint equations manually. This is essential for:</p> <ul> <li>Topology optimization</li> <li>Inverse design</li> <li>Sensitivity analysis</li> <li>Gradient-based optimization</li> </ul>"},{"location":"reference/faq/#installation-setup","title":"Installation &amp; Setup","text":""},{"location":"reference/faq/#how-do-i-install-grcwa","title":"How do I install GRCWA?","text":"<pre><code>pip install grcwa\n</code></pre> <p>For the latest development version:</p> <pre><code>git clone https://github.com/weiliangjinca/grcwa\ncd grcwa\npip install -e .\n</code></pre>"},{"location":"reference/faq/#what-are-the-dependencies","title":"What are the dependencies?","text":"<p>Required:</p> <ul> <li>Python \u2265 3.5</li> <li>numpy</li> <li>autograd</li> </ul> <p>Optional:</p> <ul> <li>nlopt (for optimization examples)</li> <li>matplotlib (for visualization)</li> <li>pytest (for testing)</li> </ul>"},{"location":"reference/faq/#how-do-i-switch-between-numpy-and-autograd-backends","title":"How do I switch between NumPy and Autograd backends?","text":"<pre><code>import grcwa\n\n# NumPy backend (faster, no gradients)\ngrcwa.set_backend('numpy')\n\n# Autograd backend (gradients enabled)\ngrcwa.set_backend('autograd')\n</code></pre> <p>Important: Set backend before creating <code>grcwa.obj</code> instances.</p>"},{"location":"reference/faq/#usage-questions","title":"Usage Questions","text":""},{"location":"reference/faq/#how-do-i-choose-the-truncation-order-ng","title":"How do I choose the truncation order (nG)?","text":"<p>Rules of thumb:</p> <ul> <li>Uniform layers: <code>nG = 11-51</code></li> <li>Smooth patterns: <code>nG = 51-101</code></li> <li>Sharp features: <code>nG = 101-301</code></li> <li>Very fine details: <code>nG = 301-501</code></li> </ul> <p>Always test convergence:</p> <pre><code>for nG in [51, 101, 201, 301]:\n    obj = grcwa.obj(nG, ...)\n    # ... setup and solve ...\n    R, T = obj.RT_Solve(normalize=1)\n    print(f\"nG={obj.nG}: R={R:.6f}, T={T:.6f}\")\n</code></pre>"},{"location":"reference/faq/#how-many-grid-points-nx-ny-should-i-use","title":"How many grid points (Nx, Ny) should I use?","text":"<p>Recommendations:</p> <ul> <li>Smooth features: 50-100</li> <li>Typical patterns: 200-400</li> <li>Sharp edges: 400-500</li> <li>Very fine details: 500-1000</li> </ul> <p>Trade-off: Higher resolution = more accurate but slower FFT.</p>"},{"location":"reference/faq/#what-units-should-i-use","title":"What units should I use?","text":"<p>GRCWA uses natural units where \\(c = \\varepsilon_0 = \\mu_0 = 1\\). You can use any consistent length unit:</p> <pre><code># Example: all in \u03bcm\nwavelength = 1.55  # \u03bcm\nfreq = 1.0 / wavelength  # \u2248 0.645\nL1 = [0.5, 0]  # \u03bcm\nthickness = 0.3  # \u03bcm\n</code></pre> <p>Key: All lengths must use the same unit.</p>"},{"location":"reference/faq/#how-do-i-convert-wavelength-to-frequency","title":"How do I convert wavelength to frequency?","text":"<p>In natural units:</p> \\[ f = \\frac{c}{\\lambda} = \\frac{1}{\\lambda} \\] <pre><code>wavelength = 1.5  # Your chosen unit\nfreq = 1.0 / wavelength\n</code></pre>"},{"location":"reference/faq/#whats-the-difference-between-p-and-s-polarization","title":"What's the difference between P and S polarization?","text":"<p>P-polarization (TM):</p> <ul> <li>Electric field in the plane of incidence</li> <li>Magnetic field perpendicular to plane of incidence</li> <li>Set <code>p_amp=1, s_amp=0</code></li> </ul> <p>S-polarization (TE):</p> <ul> <li>Electric field perpendicular to plane of incidence</li> <li>Magnetic field in the plane of incidence</li> <li>Set <code>p_amp=0, s_amp=1</code></li> </ul> <p>For normal incidence on isotropic materials, P and S give the same result.</p>"},{"location":"reference/faq/#how-do-i-define-circular-polarization","title":"How do I define circular polarization?","text":"<p>Left circular polarization (LCP):</p> <pre><code>obj.MakeExcitationPlanewave(p_amp=1, p_phase=0,\n                             s_amp=1, s_phase=np.pi/2, order=0)\n</code></pre> <p>Right circular polarization (RCP):</p> <pre><code>obj.MakeExcitationPlanewave(p_amp=1, p_phase=0,\n                             s_amp=1, s_phase=-np.pi/2, order=0)\n</code></pre>"},{"location":"reference/faq/#troubleshooting","title":"Troubleshooting","text":""},{"location":"reference/faq/#why-is-r-t-1","title":"Why is R + T \u2260 1?","text":"<p>Possible causes:</p> <ol> <li>Insufficient truncation order: Increase <code>nG</code></li> <li>Numerical instability: Reduce layer thickness or use smaller <code>nG</code></li> <li>Absorbing material: For lossy materials, \\(R + T &lt; 1\\) is correct (absorption = \\(1-R-T\\))</li> <li>Very high contrast: Use more grid points (<code>Nx, Ny</code>)</li> </ol> <p>Fix:</p> <pre><code># Test convergence\nfor nG in [101, 201, 301, 501]:\n    obj = grcwa.obj(nG, ...)\n    # ... solve ...\n    R, T = obj.RT_Solve(normalize=1)\n    print(f\"nG={nG}: R+T={R+T:.6f}, error={(R+T-1):.2e}\")\n</code></pre>"},{"location":"reference/faq/#why-am-i-getting-a-singular-matrix-error","title":"Why am I getting a singular matrix error?","text":"<p>Causes:</p> <ul> <li>Perfect normal incidence with no loss</li> <li>Perfectly symmetric structure</li> </ul> <p>Fix: Add tiny loss:</p> <pre><code>Qabs = 1e8  # Very high Q-factor\nfreq = freq * (1 + 1j / (2*Qabs))\n</code></pre> <p>Or add tiny imaginary part to epsilon:</p> <pre><code>epsilon = 4.0 + 1e-10j\n</code></pre>"},{"location":"reference/faq/#my-pattern-looks-wrong-how-do-i-debug","title":"My pattern looks wrong. How do I debug?","text":"<p>Use <code>Return_eps()</code> to visualize:</p> <pre><code>eps_recon = obj.Return_eps(which_layer=1, Nx=200, Ny=200)\n\nimport matplotlib.pyplot as plt\nplt.imshow(eps_recon.T, origin='lower')\nplt.colorbar()\nplt.title('Reconstructed Dielectric Pattern')\nplt.show()\n</code></pre> <p>Compare with your input pattern to verify correctness.</p>"},{"location":"reference/faq/#results-are-very-slow-how-to-speed-up","title":"Results are very slow. How to speed up?","text":"<p>Optimization strategies:</p> <ol> <li>Reduce truncation order: Try lower <code>nG</code> first</li> <li>Use NumPy backend: Faster than Autograd if no gradients needed</li> <li>Reduce grid resolution: Lower <code>Nx, Ny</code> if acceptable</li> <li>Use uniform layers when possible: Much faster than patterned</li> <li>Parallelize parameter sweeps:</li> </ol> <pre><code>from multiprocessing import Pool\n\ndef compute(freq):\n    obj = grcwa.obj(...)\n    # ... solve ...\n    return R, T\n\nwith Pool(8) as p:\n    results = p.map(compute, frequencies)\n</code></pre>"},{"location":"reference/faq/#how-do-i-handle-anisotropic-materials","title":"How do I handle anisotropic materials?","text":"<p>For anisotropic dielectric tensors, provide a list of 3 components:</p> <pre><code># Uniaxial material with \u03b5xx = \u03b5yy \u2260 \u03b5zz\neps_xx = 4.0\neps_yy = 4.0\neps_zz = 6.0\n\neps_tensor = [eps_xx, eps_yy, eps_zz]\n\n# For grid layer\neps_grid_xx = np.ones((Nx, Ny)) * eps_xx\neps_grid_yy = np.ones((Nx, Ny)) * eps_yy\neps_grid_zz = np.ones((Nx, Ny)) * eps_zz\n\neps_all = [eps_grid_xx.flatten(), eps_grid_yy.flatten(), eps_grid_zz.flatten()]\nobj.GridLayer_geteps(eps_all)\n</code></pre>"},{"location":"reference/faq/#advanced-usage","title":"Advanced Usage","text":""},{"location":"reference/faq/#how-do-i-do-topology-optimization","title":"How do I do topology optimization?","text":"<pre><code>import grcwa\ngrcwa.set_backend('autograd')\nimport autograd.numpy as np\nfrom autograd import grad\n\ndef objective(epsilon):\n    obj = grcwa.obj(101, [1,0], [0,1], freq, 0, 0, verbose=0)\n    obj.Add_LayerUniform(1.0, 1.0)\n    obj.Add_LayerGrid(0.5, Nx, Ny)\n    obj.Add_LayerUniform(1.0, 1.0)\n    obj.Init_Setup()\n    obj.GridLayer_geteps(epsilon.flatten())\n    obj.MakeExcitationPlanewave(1, 0, 0, 0, 0)\n    R, T = obj.RT_Solve(normalize=1)\n    return -R  # Maximize reflection\n\n# Compute gradient\ngrad_obj = grad(objective)\n\n# Use optimizer (e.g., NLOPT, scipy.optimize)\nimport nlopt\n\ndef nlopt_objective(x, grad_array):\n    if grad_array.size &gt; 0:\n        grad_array[:] = grad_obj(x)\n    return objective(x)\n\n# Setup NLOPT\nopt = nlopt.opt(nlopt.LD_MMA, Nx*Ny)\nopt.set_min_objective(nlopt_objective)\nopt.set_lower_bounds(1.0)\nopt.set_upper_bounds(12.0)\n\n# Initial guess\nepsilon_init = np.ones(Nx*Ny) * 6.0\n\n# Optimize\nepsilon_opt = opt.optimize(epsilon_init)\n</code></pre>"},{"location":"reference/faq/#can-i-simulate-isolated-objects","title":"Can I simulate isolated objects?","text":"<p>RCWA requires periodicity. For isolated objects:</p> <ol> <li>Use large unit cell (super-cell approach):</li> </ol> <pre><code># Object size: 1 \u03bcm\n# Use 10 \u03bcm \u00d7 10 \u03bcm unit cell\nL1 = [10, 0]\nL2 = [0, 10]\n\n# Place object at center, surrounded by vacuum\n</code></pre> <ol> <li>Check convergence with increasing cell size until results stabilize</li> </ol>"},{"location":"reference/faq/#how-do-i-get-reflectiontransmission-coefficients-not-just-powers","title":"How do I get reflection/transmission coefficients (not just powers)?","text":"<p>The amplitudes are stored internally. Access via:</p> <pre><code># After solving\namplitudes_in, amplitudes_out = obj.GetAmplitudes(layer=0, z_offset=0)\n</code></pre> <p>For reflection coefficients:</p> <pre><code># Reflection coefficients for each order\nr_coeffs = amplitudes_out[0:obj.nG]  # Backward propagating in input region\n</code></pre>"},{"location":"reference/faq/#how-do-i-compute-absorption","title":"How do I compute absorption?","text":"<p>For lossy materials:</p> <pre><code>R, T = obj.RT_Solve(normalize=1)\nA = 1 - R - T  # Absorption\n</code></pre> <p>Or use volume integral of \\(\\text{Im}(\\varepsilon)|E|^2\\):</p> <pre><code>absorption = obj.Volume_integral(which_layer, Mx, My, Mz, normalize=1)\n</code></pre>"},{"location":"reference/faq/#can-i-use-grcwa-for-3d-photonic-crystals","title":"Can I use GRCWA for 3D photonic crystals?","text":"<p>RCWA assumes periodicity in 2D (xy-plane) and stacking in z. For 3D photonic crystals:</p> <ul> <li>\u2705 Photonic crystal slabs (2D periodic, finite in z): Yes</li> <li>\u274c 3D bulk photonic crystals (periodic in xyz): No, use plane-wave expansion or other methods</li> </ul>"},{"location":"reference/faq/#how-do-i-cite-grcwa","title":"How do I cite GRCWA?","text":"<pre><code>@article{Jin2020,\n  title = {Inverse design of lightweight broadband reflector for relativistic lightsail propulsion},\n  author = {Jin, Weiliang and Li, Wei and Orenstein, Meir and Fan, Shanhui},\n  journal = {ACS Photonics},\n  volume = {7},\n  number = {9},\n  pages = {2350--2355},\n  year = {2020},\n  publisher = {ACS Publications}\n}\n</code></pre>"},{"location":"reference/faq/#common-error-messages","title":"Common Error Messages","text":""},{"location":"reference/faq/#indexerror-index-out-of-range","title":"\"IndexError: index out of range\"","text":"<p>Cause: Mismatch between number of patterned layers and epsilon arrays provided.</p> <p>Fix: Ensure <code>epsilon.flatten()</code> has correct total length.</p>"},{"location":"reference/faq/#valueerror-operands-could-not-be-broadcast-together","title":"\"ValueError: operands could not be broadcast together\"","text":"<p>Cause: Array shape mismatch in pattern definition.</p> <p>Fix: Check that pattern has shape <code>(Nx, Ny)</code> and use <code>indexing='ij'</code> in meshgrid.</p>"},{"location":"reference/faq/#linalgerror-singular-matrix","title":"\"LinAlgError: Singular matrix\"","text":"<p>Cause: Numerical singularity, often at normal incidence with no loss.</p> <p>Fix: Add tiny loss:</p> <pre><code>freq = freq * (1 + 1e-10j)\n</code></pre>"},{"location":"reference/faq/#still-have-questions","title":"Still Have Questions?","text":"<ul> <li>Check the Troubleshooting Guide</li> <li>Read the Tutorials</li> <li>Browse Examples</li> <li>Open an issue on GitHub</li> <li>Contact: jwlaaa@gmail.com</li> </ul>"},{"location":"reference/variables/","title":"Variables and Conventions Reference","text":"<p>This page documents all important variables, their meanings, and conventions used in GRCWA.</p>"},{"location":"reference/variables/#physical-constants-and-units","title":"Physical Constants and Units","text":""},{"location":"reference/variables/#natural-units","title":"Natural Units","text":"<p>GRCWA uses natural units where:</p> Constant Value Meaning \\(\\varepsilon_0\\) 1 Vacuum permittivity \\(\\mu_0\\) 1 Vacuum permeability \\(c\\) 1 Speed of light \\(Z_0 = \\sqrt{\\mu_0/\\varepsilon_0}\\) 1 Vacuum impedance <p>Implications:</p> <ul> <li>Choose any length unit (\u03bcm, nm, mm, etc.)</li> <li>Frequency \\(f = 1/\\lambda\\) in your chosen units</li> <li>Dielectric constants are dimensionless: \\(\\varepsilon_r = \\varepsilon/\\varepsilon_0\\)</li> <li>All equations simplified by \\(c=1\\)</li> </ul>"},{"location":"reference/variables/#example-wavelength-155-m","title":"Example: Wavelength 1.55 \u03bcm","text":"<pre><code>wavelength = 1.55  # \u03bcm\nfreq = 1.0 / wavelength  # freq \u2248 0.645 in natural units\nL1 = [0.5, 0]  # Lattice constant 0.5 \u03bcm\nthickness = 0.3  # Layer thickness 0.3 \u03bcm\n</code></pre> <p>All lengths must use the same unit (\u03bcm in this example).</p>"},{"location":"reference/variables/#time-harmonic-convention","title":"Time Harmonic Convention","text":"<p>Fields oscillate as:</p> \\[ \\mathbf{E}(\\mathbf{r}, t) = \\text{Re}[\\mathbf{E}(\\mathbf{r}) e^{-i\\omega t}] \\] <p>Convention: \\(e^{-i\\omega t}\\) (not \\(e^{+i\\omega t}\\))</p> <p>Implications:</p> <ul> <li>Phase advance in space: \\(e^{+ikz}\\) for forward propagation</li> <li>Absorption: \\(\\varepsilon = \\varepsilon' + i\\varepsilon''\\) with \\(\\varepsilon'' &gt; 0\\)</li> <li>Evanescent decay: \\(e^{-\\kappa z}\\) with \\(\\kappa &gt; 0\\)</li> </ul>"},{"location":"reference/variables/#core-class-grcwaobj","title":"Core Class: <code>grcwa.obj</code>","text":""},{"location":"reference/variables/#constructor-parameters","title":"Constructor Parameters","text":"<pre><code>obj = grcwa.obj(nG, L1, L2, freq, theta, phi, verbose=1)\n</code></pre> Parameter Type Units Description <code>nG</code> int - Target number of Fourier harmonics <code>L1</code> list[float, float] length Lattice vector 1: <code>[Lx1, Ly1]</code> <code>L2</code> list[float, float] length Lattice vector 2: <code>[Lx2, Ly2]</code> <code>freq</code> float 1/length Frequency (\\(\\omega/(2\\pi c)\\)) <code>theta</code> float radians Polar incident angle (from z-axis) <code>phi</code> float radians Azimuthal angle (in xy-plane from x-axis) <code>verbose</code> int - Verbosity level: 0 (quiet), 1 (normal), 2 (debug) <p>Notes:</p> <ul> <li>Actual <code>nG</code> may differ due to truncation scheme</li> <li><code>L1</code>, <code>L2</code> need not be orthogonal (supports oblique lattices)</li> <li>Normal incidence: <code>theta=0</code>, <code>phi=0</code></li> <li>Oblique incidence: \\(0 &lt; \\theta &lt; \\pi/2\\)</li> </ul>"},{"location":"reference/variables/#lattice-vectors","title":"Lattice Vectors","text":"<pre><code>L1 = [Lx1, Ly1]  # First lattice vector\nL2 = [Lx2, Ly2]  # Second lattice vector\n</code></pre> <p>Common lattices:</p> <p>Square: <pre><code>a = 1.0\nL1 = [a, 0]\nL2 = [0, a]\n</code></pre></p> <p>Rectangular: <pre><code>a, b = 1.0, 0.5\nL1 = [a, 0]\nL2 = [0, b]\n</code></pre></p> <p>Hexagonal: <pre><code>a = 1.0\nL1 = [a, 0]\nL2 = [a/2, a*np.sqrt(3)/2]  # 60\u00b0 angle\n</code></pre></p> <p>Rhombohedral: <pre><code>a = 1.0\nangle = 75 * np.pi/180\nL1 = [a, 0]\nL2 = [a*np.cos(angle), a*np.sin(angle)]\n</code></pre></p>"},{"location":"reference/variables/#angles","title":"Angles","text":"<p>Theta (\\(\\theta\\)): Polar angle from z-axis</p> <ul> <li>\\(\\theta = 0\\): Normal incidence</li> <li>\\(0 &lt; \\theta &lt; \\pi/2\\): Oblique incidence from above</li> <li>\\(\\pi/2 &lt; \\theta &lt; \\pi\\): Grazing incidence (rarely used)</li> </ul> <p>Phi (\\(\\phi\\)): Azimuthal angle in xy-plane</p> <ul> <li>\\(\\phi = 0\\): Incident in xz-plane</li> <li>\\(\\phi = \\pi/2\\): Incident in yz-plane</li> <li>General: Incident direction is \\((\\sin\\theta\\cos\\phi, \\sin\\theta\\sin\\phi, \\cos\\theta)\\)</li> </ul> <p>Wave vector:</p> \\[ \\mathbf{k}_{\\text{inc}} = \\omega\\sqrt{\\varepsilon_{\\text{in}}}(\\sin\\theta\\cos\\phi, \\sin\\theta\\sin\\phi, \\cos\\theta) \\]"},{"location":"reference/variables/#layer-variables","title":"Layer Variables","text":""},{"location":"reference/variables/#layer-types","title":"Layer Types","text":"Type ID Method Description 0 <code>Add_LayerUniform</code> Homogeneous dielectric 1 <code>Add_LayerGrid</code> Pattern defined on Cartesian grid 2 <code>Add_LayerFourier</code> Pattern defined by Fourier coefficients"},{"location":"reference/variables/#uniform-layer","title":"Uniform Layer","text":"<pre><code>obj.Add_LayerUniform(thickness, epsilon)\n</code></pre> Parameter Type Units Description <code>thickness</code> float length Layer thickness <code>epsilon</code> float or complex - Relative permittivity \\(\\varepsilon_r\\) <p>Examples:</p> <pre><code># Vacuum\nobj.Add_LayerUniform(1.0, 1.0)\n\n# Silicon (n=3.48)\nobj.Add_LayerUniform(0.5, 3.48**2)  # \u03b5 = n\u00b2\n\n# Silicon with loss\nobj.Add_LayerUniform(0.5, 12.1 + 0.1j)  # \u03b5 = \u03b5' + i\u03b5''\n\n# Silver (Drude model)\neps_inf = 5.0\nomega_p = 9.0  # Plasma frequency\ngamma = 0.02  # Damping\neps_Ag = eps_inf - omega_p**2 / (freq**2 + 1j*freq*gamma)\nobj.Add_LayerUniform(0.02, eps_Ag)\n</code></pre>"},{"location":"reference/variables/#patterned-layer-grid","title":"Patterned Layer (Grid)","text":"<pre><code>obj.Add_LayerGrid(thickness, Nx, Ny)\n</code></pre> Parameter Type Units Description <code>thickness</code> float length Layer thickness <code>Nx</code> int - Number of grid points in x <code>Ny</code> int - Number of grid points in y <p>Later, input pattern:</p> <pre><code>epsilon_grid = ...  # Shape: (Nx, Ny)\nobj.GridLayer_geteps(epsilon_grid.flatten())\n</code></pre> <p>Pattern coordinates:</p> <ul> <li>Grid points at \\((i/(N_x-1), j/(N_y-1))\\) for \\(i=0,\\ldots,N_x-1\\), \\(j=0,\\ldots,N_y-1\\)</li> <li>Normalized coordinates \\(x, y \\in [0, 1]\\)</li> <li>Physical coordinates: multiply by lattice vectors</li> </ul> <p>Multiple patterned layers:</p> <p>If you have multiple patterned layers, flatten and concatenate:</p> <pre><code>epsilon1 = ...  # (Nx1, Ny1)\nepsilon2 = ...  # (Nx2, Ny2)\nepsilon_all = np.concatenate([epsilon1.flatten(), epsilon2.flatten()])\nobj.GridLayer_geteps(epsilon_all)\n</code></pre>"},{"location":"reference/variables/#grid-resolution","title":"Grid Resolution","text":"<p>Recommendations:</p> Feature Size Recommended Nx, Ny Smooth variations 50-100 Sharp features 200-400 Very fine details 500-1000 <p>Trade-off: Higher resolution \u2192 more accurate but slower FFT.</p>"},{"location":"reference/variables/#fourier-harmonics","title":"Fourier Harmonics","text":""},{"location":"reference/variables/#truncation-order","title":"Truncation Order","text":"<pre><code>nG = 101  # Target number\n</code></pre> <p>After initialization, actual <code>nG</code>:</p> <pre><code>obj.nG  # Actual number used\nobj.G   # Array of (m, n) indices, shape: (nG, 2)\n</code></pre> <p>Truncation schemes:</p> <ul> <li>Circular (<code>Gmethod=0</code>, default): \\(m^2 + n^2 \\leq N_{\\max}^2\\)</li> <li>Rectangular (<code>Gmethod=1</code>): \\(|m| \\leq M\\), \\(|n| \\leq N\\)</li> </ul> <p>Convergence:</p> <pre><code># Test convergence\nnG_values = [51, 101, 201, 301, 501]\nfor nG in nG_values:\n    obj = grcwa.obj(nG, ...)\n    # ... solve ...\n    R, T = obj.RT_Solve()\n    print(f\"nG={obj.nG}, R={R:.6f}, T={T:.6f}\")\n</code></pre> <p>Converged when R, T don't change significantly with increasing <code>nG</code>.</p>"},{"location":"reference/variables/#reciprocal-lattice","title":"Reciprocal Lattice","text":"<p>After <code>Init_Setup()</code>:</p> Attribute Type Description <code>obj.Lk1</code> array Reciprocal lattice vector 1 <code>obj.Lk2</code> array Reciprocal lattice vector 2 <code>obj.G</code> array (nG, 2) Array of \\((m, n)\\) indices <code>obj.kx</code> array (nG,) x-components of wave vectors <code>obj.ky</code> array (nG,) y-components of wave vectors <p>Reciprocal lattice vectors:</p> \\[ \\mathbf{K}_1 \\cdot \\mathbf{L}_1 = 2\\pi, \\quad \\mathbf{K}_1 \\cdot \\mathbf{L}_2 = 0 \\] \\[ \\mathbf{K}_2 \\cdot \\mathbf{L}_1 = 0, \\quad \\mathbf{K}_2 \\cdot \\mathbf{L}_2 = 2\\pi \\] <p>Wave vectors for each order:</p> \\[ k_{x,mn} = k_{x0} + m K_{1x} + n K_{2x} \\] \\[ k_{y,mn} = k_{y0} + m K_{1y} + n K_{2y} \\] <p>Access in code:</p> <pre><code>kx_mn = obj.kx  # Shape: (nG,)\nky_mn = obj.ky  # Shape: (nG,)\nG_indices = obj.G  # Shape: (nG, 2), each row is (m, n)\n</code></pre>"},{"location":"reference/variables/#excitation-variables","title":"Excitation Variables","text":""},{"location":"reference/variables/#plane-wave-excitation","title":"Plane Wave Excitation","text":"<pre><code>obj.MakeExcitationPlanewave(p_amp, p_phase, s_amp, s_phase, order, direction=0)\n</code></pre> Parameter Type Units Description <code>p_amp</code> float - P-polarization amplitude <code>p_phase</code> float radians P-polarization phase <code>s_amp</code> float - S-polarization amplitude <code>s_phase</code> float radians S-polarization phase <code>order</code> int - Diffraction order index (usually 0) <code>direction</code> int - 0: from top, 1: from bottom <p>Polarization definitions:</p> <p>P-polarization (TM): E-field in plane of incidence</p> \\[ \\hat{p} = \\frac{\\mathbf{k}_\\parallel \\times \\hat{z} \\times \\mathbf{k}}{|\\mathbf{k}_\\parallel \\times \\hat{z} \\times \\mathbf{k}|} \\] <p>S-polarization (TE): E-field perpendicular to plane of incidence</p> \\[ \\hat{s} = \\frac{\\mathbf{k} \\times \\hat{z}}{|\\mathbf{k} \\times \\hat{z}|} \\] <p>Common cases:</p> <pre><code># P-polarized\nobj.MakeExcitationPlanewave(1, 0, 0, 0, 0)\n\n# S-polarized\nobj.MakeExcitationPlanewave(0, 0, 1, 0, 0)\n\n# 45\u00b0 linear polarization\nobj.MakeExcitationPlanewave(1, 0, 1, 0, 0)\n\n# Left circular polarization (LCP)\nobj.MakeExcitationPlanewave(1, 0, 1, np.pi/2, 0)\n\n# Right circular polarization (RCP)\nobj.MakeExcitationPlanewave(1, 0, 1, -np.pi/2, 0)\n</code></pre>"},{"location":"reference/variables/#solution-variables","title":"Solution Variables","text":""},{"location":"reference/variables/#reflection-and-transmission","title":"Reflection and Transmission","text":"<pre><code>R, T = obj.RT_Solve(normalize=1, byorder=0)\n</code></pre> Parameter Type Description <code>normalize</code> int 0: raw, 1: normalized <code>byorder</code> int 0: total, 1: by order <p>Returns:</p> <ul> <li><code>normalize=1, byorder=0</code>: \\((R, T)\\) scalars, total power</li> <li><code>normalize=1, byorder=1</code>: \\((R_i, T_i)\\) arrays of length <code>nG</code></li> </ul> <p>Normalization:</p> <p>With <code>normalize=1</code>:</p> \\[ R = \\sum_{mn} \\frac{\\text{Re}(k_{z,mn}^{\\text{refl}})}{\\text{Re}(k_{z,\\text{inc}})} |r_{mn}|^2 \\] \\[ T = \\sum_{mn} \\frac{\\text{Re}(k_{z,mn}^{\\text{trans}}) \\varepsilon_{\\text{in}}}{\\text{Re}(k_{z,\\text{inc}}) \\varepsilon_{\\text{out}}} |t_{mn}|^2 \\] <p>Energy conservation: \\(R + T = 1\\) for lossless structures.</p>"},{"location":"reference/variables/#field-amplitudes","title":"Field Amplitudes","text":"<pre><code>a_i, b_i = obj.GetAmplitudes(which_layer, z_offset)\n</code></pre> Parameter Type Description <code>which_layer</code> int Layer index (0-based) <code>z_offset</code> float Position within layer <p>Returns:</p> <ul> <li><code>a_i</code>: Forward mode amplitudes, shape <code>(2*nG,)</code> for \\((E_x, E_y)\\) components</li> <li><code>b_i</code>: Backward mode amplitudes, shape <code>(2*nG,)</code></li> </ul> <p>Format: <code>[Ex_0, Ex_1, ..., Ex_nG, Ey_0, Ey_1, ..., Ey_nG]</code></p>"},{"location":"reference/variables/#fields-in-fourier-space","title":"Fields in Fourier Space","text":"<pre><code>[Ex_mn, Ey_mn, Ez_mn], [Hx_mn, Hy_mn, Hz_mn] = obj.Solve_FieldFourier(which_layer, z_offset)\n</code></pre> <p>Returns: 6 arrays, each shape <code>(nG,)</code>, complex values</p> <ul> <li>Fourier coefficients for each component</li> <li>To get total field: sum over all orders with phase factors</li> </ul>"},{"location":"reference/variables/#fields-in-real-space","title":"Fields in Real Space","text":"<pre><code>[Ex, Ey, Ez], [Hx, Hy, Hz] = obj.Solve_FieldOnGrid(which_layer, z_offset, Nxy)\n</code></pre> Parameter Type Description <code>Nxy</code> list[int, int] Grid size <code>[Nx, Ny]</code> <p>Returns: 6 arrays, each shape <code>(Nx, Ny)</code>, complex values</p> <ul> <li>Electric and magnetic field components on real-space grid</li> <li>Intensity: \\(I = |E_x|^2 + |E_y|^2 + |E_z|^2\\)</li> </ul>"},{"location":"reference/variables/#internal-variables","title":"Internal Variables","text":""},{"location":"reference/variables/#layer-storage","title":"Layer Storage","text":"Attribute Description <code>obj.Layer_N</code> Total number of layers <code>obj.thickness_list</code> List of layer thicknesses <code>obj.id_list</code> Layer type identifiers <code>obj.Uniform_ep_list</code> Dielectric constants for uniform layers <code>obj.GridLayer_N</code> Number of grid-based layers <code>obj.GridLayer_Nxy_list</code> Grid sizes for each patterned layer"},{"location":"reference/variables/#eigenmode-variables","title":"Eigenmode Variables","text":"Attribute Description <code>obj.q_list</code> Eigenvalues \\(q\\) for each layer <code>obj.phi_list</code> Eigenvectors for each layer <code>obj.kp_list</code> \\(K_\\perp\\) matrices for each layer <p>These are computed by <code>Init_Setup()</code> and used internally for solving.</p>"},{"location":"reference/variables/#common-combinations","title":"Common Combinations","text":""},{"location":"reference/variables/#spectral-sweep","title":"Spectral Sweep","text":"<pre><code>wavelengths = np.linspace(0.4, 0.8, 100)\nR_spectrum = []\n\nfor wl in wavelengths:\n    freq = 1.0 / wl\n    obj = grcwa.obj(nG, L1, L2, freq, theta, phi, verbose=0)\n    # ... add layers, solve ...\n    R, T = obj.RT_Solve(normalize=1)\n    R_spectrum.append(R)\n</code></pre>"},{"location":"reference/variables/#angle-sweep","title":"Angle Sweep","text":"<pre><code>angles = np.linspace(0, 80, 50) * np.pi/180\nR_angle = []\n\nfor theta in angles:\n    obj = grcwa.obj(nG, L1, L2, freq, theta, phi=0, verbose=0)\n    # ... add layers, solve ...\n    R, T = obj.RT_Solve(normalize=1)\n    R_angle.append(R)\n</code></pre>"},{"location":"reference/variables/#polarization-sweep","title":"Polarization Sweep","text":"<pre><code>pols = np.linspace(0, np.pi, 90)  # Polarization angle\nR_pol = []\n\nfor pol in pols:\n    obj = grcwa.obj(nG, L1, L2, freq, theta, phi, verbose=0)\n    # ... add layers ...\n    obj.MakeExcitationPlanewave(np.cos(pol), 0, np.sin(pol), 0, 0)\n    R, T = obj.RT_Solve(normalize=1)\n    R_pol.append(R)\n</code></pre>"},{"location":"reference/variables/#autograd-variables","title":"Autograd Variables","text":"<p>When using <code>grcwa.set_backend('autograd')</code>:</p> <pre><code>import autograd.numpy as np\nfrom autograd import grad\n\n# Autogradable parameters\nepsilon_grid = np.array(...)  # Must use autograd.numpy\nfreq = np.array(1.0)\ntheta = np.array(0.1)\nthickness = np.array(0.5)\n\n# Compute gradient\ndef objective(eps):\n    # ... setup and solve ...\n    R, T = obj.RT_Solve()\n    return -R  # Maximize R\n\ngrad_obj = grad(objective)\ngradient = grad_obj(epsilon_grid)\n</code></pre> <p>Autogradable parameters:</p> <ul> <li>\u2705 Dielectric values on grid</li> <li>\u2705 Frequency <code>freq</code></li> <li>\u2705 Angles <code>theta</code>, <code>phi</code></li> <li>\u2705 Layer thickness</li> <li>\u2705 Periodicity scaling <code>Pscale</code></li> <li>\u274c Truncation order <code>nG</code></li> <li>\u274c Grid sizes <code>Nx</code>, <code>Ny</code></li> <li>\u274c Layer numbers</li> </ul>"},{"location":"reference/variables/#summary-table","title":"Summary Table","text":"Variable Symbol Type Units Description Frequency \\(\\omega/(2\\pi)\\) float 1/length Operating frequency Wavelength \\(\\lambda\\) float length \\(\\lambda = 1/f\\) Polar angle \\(\\theta\\) float radians Incident angle from z-axis Azimuthal angle \\(\\phi\\) float radians Angle in xy-plane Lattice vectors \\(\\mathbf{L}_1, \\mathbf{L}_2\\) list length Real-space periodicity Reciprocal vectors \\(\\mathbf{K}_1, \\mathbf{K}_2\\) array 1/length Fourier-space periodicity Truncation order \\(N_G\\) int - Number of Fourier harmonics Layer thickness \\(d\\) float length Thickness of each layer Dielectric constant \\(\\varepsilon\\) complex - Relative permittivity Reflection \\(R\\) float - Reflected power fraction Transmission \\(T\\) float - Transmitted power fraction"},{"location":"reference/variables/#next-steps","title":"Next Steps","text":"<ul> <li>Physical Units: Unit conversion examples</li> <li>Troubleshooting: Common issues and fixes</li> <li>FAQ: Frequently asked questions</li> <li>API Reference: Complete function documentation</li> </ul>"},{"location":"theory/mathematics/","title":"Mathematical Formulation of RCWA","text":"<p>This page derives the mathematical framework of RCWA in detail.</p>"},{"location":"theory/mathematics/#field-expansion","title":"Field Expansion","text":""},{"location":"theory/mathematics/#fourier-series-expansion","title":"Fourier Series Expansion","text":"<p>For a periodic structure with lattice vectors \\(\\mathbf{L}_1, \\mathbf{L}_2\\), any periodic function can be expanded:</p> \\[ f(\\mathbf{r}_\\parallel) = \\sum_{m,n} f_{mn} \\exp(i\\mathbf{G}_{mn} \\cdot \\mathbf{r}_\\parallel) \\] <p>where \\(\\mathbf{G}_{mn} = m\\mathbf{K}_1 + n\\mathbf{K}_2\\) are reciprocal lattice vectors.</p>"},{"location":"theory/mathematics/#field-components","title":"Field Components","text":"<p>The electric and magnetic fields in each layer are:</p> \\[ \\mathbf{E}(\\mathbf{r}) = \\sum_{mn} \\mathbf{E}_{mn}(z) \\exp(i\\mathbf{k}_{mn,\\parallel} \\cdot \\mathbf{r}_\\parallel) \\] \\[ \\mathbf{H}(\\mathbf{r}) = \\sum_{mn} \\mathbf{H}_{mn}(z) \\exp(i\\mathbf{k}_{mn,\\parallel} \\cdot \\mathbf{r}_\\parallel) \\] <p>where \\(\\mathbf{k}_{mn,\\parallel} = \\mathbf{k}_{\\parallel,0} + \\mathbf{G}_{mn}\\).</p>"},{"location":"theory/mathematics/#eigenvalue-problem-in-patterned-layers","title":"Eigenvalue Problem in Patterned Layers","text":""},{"location":"theory/mathematics/#maxwells-equations-in-fourier-space","title":"Maxwell's Equations in Fourier Space","text":"<p>Applying Fourier transform to curl equations:</p> \\[ \\nabla \\times \\mathbf{E} = i\\omega\\mu\\mathbf{H} \\] \\[ \\nabla \\times \\mathbf{H} = -i\\omega\\varepsilon\\mathbf{E} \\] <p>For TM modes (p-polarization), we eliminate \\(\\mathbf{H}\\) to get:</p> \\[ \\nabla \\times (\\varepsilon^{-1} \\nabla \\times \\mathbf{H}) = \\omega^2 \\mu \\mathbf{H} \\] <p>For TE modes (s-polarization):</p> \\[ \\nabla \\times (\\mu^{-1} \\nabla \\times \\mathbf{E}) = \\omega^2 \\varepsilon \\mathbf{E} \\]"},{"location":"theory/mathematics/#tangential-field-formulation","title":"Tangential Field Formulation","text":"<p>We work with tangential field components \\((E_x, E_y, H_x, H_y)\\) since they are continuous across interfaces.</p> <p>Define vectors:</p> \\[ \\mathbf{E}_\\parallel = \\begin{pmatrix} E_x \\\\ E_y \\end{pmatrix}, \\quad \\mathbf{H}_\\parallel = \\begin{pmatrix} H_x \\\\ H_y \\end{pmatrix} \\] <p>From Maxwell's equations:</p> \\[ \\frac{\\partial}{\\partial z} \\mathbf{E}_\\parallel = i\\omega\\mu \\hat{z} \\times \\mathbf{H}_\\parallel - i\\mathbf{k}_\\parallel E_z \\] \\[ \\frac{\\partial}{\\partial z} \\mathbf{H}_\\parallel = -i\\omega\\varepsilon \\hat{z} \\times \\mathbf{E}_\\parallel - i\\mathbf{k}_\\parallel H_z \\]"},{"location":"theory/mathematics/#eliminating-normal-components","title":"Eliminating Normal Components","text":"<p>From \\(\\nabla \\cdot \\mathbf{D} = 0\\):</p> \\[ i k_x E_x + i k_y E_y + \\frac{\\partial (\\varepsilon E_z)}{\\partial z} = 0 \\] <p>For z-invariant \\(\\varepsilon\\) in each layer:</p> \\[ E_z = -\\frac{1}{\\varepsilon}(k_x E_x + k_y E_y) \\] <p>Similarly from \\(\\nabla \\cdot \\mathbf{B} = 0\\):</p> \\[ H_z = -\\frac{1}{\\mu}(k_x H_x + k_y H_y) \\]"},{"location":"theory/mathematics/#matrix-formulation","title":"Matrix Formulation","text":"<p>Define the \\(K_\\perp\\) operator:</p> \\[ K_\\perp = \\begin{pmatrix} k_y^2 &amp; -k_x k_y \\\\ -k_x k_y &amp; k_x^2 \\end{pmatrix} \\] <p>This acts on the Fourier space with convolution matrices.</p> <p>The coupled wave equations become:</p> \\[ \\frac{\\partial}{\\partial z} \\begin{pmatrix} \\mathbf{E}_\\parallel \\\\ \\mathbf{H}_\\parallel \\end{pmatrix} = i \\begin{pmatrix} 0 &amp; A \\\\ B &amp; 0 \\end{pmatrix} \\begin{pmatrix} \\mathbf{E}_\\parallel \\\\ \\mathbf{H}_\\parallel \\end{pmatrix} \\] <p>where \\(A\\) and \\(B\\) are matrices involving \\(\\varepsilon\\), \\(\\mu\\), and \\(K_\\perp\\).</p>"},{"location":"theory/mathematics/#eigenvalue-problem","title":"Eigenvalue Problem","text":"<p>Substituting \\(\\exp(iq z)\\) dependence:</p> \\[ \\begin{pmatrix} \\mathbf{E}_\\parallel \\\\ \\mathbf{H}_\\parallel \\end{pmatrix} = \\begin{pmatrix} \\boldsymbol{\\phi}_E \\\\ \\boldsymbol{\\phi}_H \\end{pmatrix} e^{iq z} \\] <p>This gives the eigenvalue equation:</p> \\[ \\begin{pmatrix} 0 &amp; A \\\\ B &amp; 0 \\end{pmatrix} \\begin{pmatrix} \\boldsymbol{\\phi}_E \\\\ \\boldsymbol{\\phi}_H \\end{pmatrix} = q \\begin{pmatrix} \\boldsymbol{\\phi}_E \\\\ \\boldsymbol{\\phi}_H \\end{pmatrix} \\] <p>Or equivalently:</p> \\[ AB \\boldsymbol{\\phi}_H = q^2 \\boldsymbol{\\phi}_H \\] \\[ BA \\boldsymbol{\\phi}_E = q^2 \\boldsymbol{\\phi}_E \\] <p>The eigenvalues \\(q\\) are the \\(z\\)-components of wave vectors for eigenmodes.</p>"},{"location":"theory/mathematics/#convolution-matrices","title":"Convolution Matrices","text":""},{"location":"theory/mathematics/#dielectric-fourier-transform","title":"Dielectric Fourier Transform","text":"<p>The dielectric function is expanded:</p> \\[ \\varepsilon(x,y) = \\sum_{mn} \\varepsilon_{mn} \\exp(i\\mathbf{G}_{mn} \\cdot \\mathbf{r}_\\parallel) \\] <p>Fourier coefficients:</p> \\[ \\varepsilon_{mn} = \\frac{1}{A_{\\text{cell}}} \\int_{\\text{cell}} \\varepsilon(x,y) \\exp(-i\\mathbf{G}_{mn} \\cdot \\mathbf{r}_\\parallel) dx dy \\] <p>In practice, computed via 2D FFT:</p> \\[ \\varepsilon_{mn} = \\text{FFT2D}[\\varepsilon(x,y)] \\]"},{"location":"theory/mathematics/#convolution-in-fourier-space","title":"Convolution in Fourier Space","text":"<p>Multiplication in real space \u2192 convolution in Fourier space:</p> \\[ [\\varepsilon(x,y) E_x(x,y,z)]_{mn} = \\sum_{m'n'} \\varepsilon_{m-m',n-n'} E_{x,m'n'}(z) \\] <p>This is represented as a matrix multiplication:</p> \\[ (\\varepsilon \\mathbf{E})_{mn} = \\sum_{m'n'} [\\mathcal{E}]_{mn,m'n'} E_{m'n'} \\] <p>where \\([\\mathcal{E}]_{mn,m'n'} = \\varepsilon_{m-m',n-n'}\\) is the convolution matrix.</p>"},{"location":"theory/mathematics/#laurents-rule-for-varepsilon-1","title":"Laurent's Rule for \\(\\varepsilon^{-1}\\)","text":"<p>For products involving \\(\\varepsilon^{-1}\\), direct Fourier transform of \\(1/\\varepsilon(x,y)\\) gives:</p> \\[ [\\varepsilon^{-1}]_{mn} = \\text{FFT2D}[1/\\varepsilon(x,y)] \\] <p>This is Laurent's rule and provides better convergence for \\(\\varepsilon^{-1}\\) than inverting \\(\\mathcal{E}\\).</p>"},{"location":"theory/mathematics/#s-matrix-algorithm","title":"S-Matrix Algorithm","text":""},{"location":"theory/mathematics/#layer-transfer-matrix","title":"Layer Transfer Matrix","text":"<p>Within a uniform or patterned layer, the solution is:</p> \\[ \\begin{pmatrix} \\mathbf{E}_\\parallel(z) \\\\ \\mathbf{H}_\\parallel(z) \\end{pmatrix} = \\sum_j c_j^+ \\begin{pmatrix} \\boldsymbol{\\phi}_{E,j} \\\\ \\boldsymbol{\\phi}_{H,j} \\end{pmatrix} e^{iq_j z} + \\sum_j c_j^- \\begin{pmatrix} \\boldsymbol{\\phi}_{E,j} \\\\ -\\boldsymbol{\\phi}_{H,j} \\end{pmatrix} e^{-iq_j z} \\] <p>where \\(c_j^+\\) and \\(c_j^-\\) are forward and backward mode amplitudes.</p> <p>At two positions \\(z_1\\) and \\(z_2 = z_1 + d\\):</p> \\[ \\begin{pmatrix} \\mathbf{E}_\\parallel(z_2) \\\\ \\mathbf{H}_\\parallel(z_2) \\end{pmatrix} = T \\begin{pmatrix} \\mathbf{E}_\\parallel(z_1) \\\\ \\mathbf{H}_\\parallel(z_1) \\end{pmatrix} \\] <p>where \\(T\\) is the transfer matrix.</p>"},{"location":"theory/mathematics/#s-matrix-definition","title":"S-Matrix Definition","text":"<p>The scattering matrix (S-matrix) relates incoming and outgoing waves:</p> \\[ \\begin{pmatrix} \\mathbf{c}^+_{\\text{out}} \\\\ \\mathbf{c}^-_{\\text{in}} \\end{pmatrix} = \\begin{pmatrix} S_{11} &amp; S_{12} \\\\ S_{21} &amp; S_{22} \\end{pmatrix} \\begin{pmatrix} \\mathbf{c}^+_{\\text{in}} \\\\ \\mathbf{c}^-_{\\text{out}} \\end{pmatrix} \\] <p>where:</p> <ul> <li>\\(S_{11}\\): Reflection from above</li> <li>\\(S_{22}\\): Reflection from below</li> <li>\\(S_{12}\\), \\(S_{21}\\): Transmission</li> </ul>"},{"location":"theory/mathematics/#s-matrix-composition","title":"S-Matrix Composition","text":"<p>For two layers with S-matrices \\(S^{(A)}\\) and \\(S^{(B)}\\) stacked in sequence:</p> \\[ S^{(AB)}_{11} = S^{(A)}_{11} + S^{(A)}_{12} (I - S^{(B)}_{11} S^{(A)}_{22})^{-1} S^{(B)}_{11} S^{(A)}_{21} \\] \\[ S^{(AB)}_{12} = S^{(A)}_{12} (I - S^{(B)}_{11} S^{(A)}_{22})^{-1} S^{(B)}_{12} \\] \\[ S^{(AB)}_{21} = S^{(B)}_{21} (I - S^{(A)}_{22} S^{(B)}_{11})^{-1} S^{(A)}_{21} \\] \\[ S^{(AB)}_{22} = S^{(B)}_{22} + S^{(B)}_{21} (I - S^{(A)}_{22} S^{(B)}_{11})^{-1} S^{(A)}_{22} S^{(B)}_{12} \\] <p>This allows building the total S-matrix layer by layer.</p>"},{"location":"theory/mathematics/#boundary-conditions-at-inputoutput","title":"Boundary Conditions at Input/Output","text":""},{"location":"theory/mathematics/#input-region","title":"Input Region","text":"<p>Semi-infinite uniform region with \\(\\varepsilon_{\\text{in}}\\):</p> \\[ \\mathbf{E}^{\\text{in}} = \\mathbf{E}_{\\text{inc}} e^{i\\mathbf{k}_{\\text{inc}} \\cdot \\mathbf{r}} + \\sum_{mn} r_{mn} \\mathbf{E}_{mn}^{\\text{refl}} e^{i\\mathbf{k}_{mn}^{\\text{refl}} \\cdot \\mathbf{r}} \\] <p>where:</p> <ul> <li>\\(\\mathbf{E}_{\\text{inc}}\\): Incident field</li> <li>\\(r_{mn}\\): Reflection coefficients for each order</li> </ul>"},{"location":"theory/mathematics/#output-region","title":"Output Region","text":"<p>Semi-infinite uniform region with \\(\\varepsilon_{\\text{out}}\\):</p> \\[ \\mathbf{E}^{\\text{out}} = \\sum_{mn} t_{mn} \\mathbf{E}_{mn}^{\\text{trans}} e^{i\\mathbf{k}_{mn}^{\\text{trans}} \\cdot \\mathbf{r}} \\] <p>where \\(t_{mn}\\) are transmission coefficients.</p>"},{"location":"theory/mathematics/#solving-for-coefficients","title":"Solving for Coefficients","text":"<p>Applying boundary conditions at top and bottom interfaces:</p> \\[ \\begin{pmatrix} \\mathbf{r} \\\\ \\mathbf{t} \\end{pmatrix} = S_{\\text{total}} \\begin{pmatrix} \\mathbf{inc} \\\\ 0 \\end{pmatrix} \\] <p>where \\(S_{\\text{total}}\\) is the total S-matrix of the entire structure.</p>"},{"location":"theory/mathematics/#power-computation","title":"Power Computation","text":""},{"location":"theory/mathematics/#normalized-poynting-flux","title":"Normalized Poynting Flux","text":"<p>For each diffraction order \\((m,n)\\), the normalized power is:</p> \\[ P_{mn} = \\frac{1}{2} \\text{Re}\\left( \\frac{k_{z,mn}}{\\omega\\mu} \\right) |A_{mn}|^2 \\] <p>where \\(A_{mn}\\) is the field amplitude.</p>"},{"location":"theory/mathematics/#reflection-and-transmission","title":"Reflection and Transmission","text":"<p>Total reflection:</p> \\[ R = \\sum_{mn} \\frac{k_{z,mn}^{\\text{refl}} / \\omega\\mu_{\\text{in}}}{k_{z,\\text{inc}} / \\omega\\mu_{\\text{in}}} |r_{mn}|^2 = \\sum_{mn} \\frac{\\text{Re}(k_{z,mn}^{\\text{refl}})}{\\text{Re}(k_{z,\\text{inc}})} |r_{mn}|^2 \\] <p>Total transmission:</p> \\[ T = \\sum_{mn} \\frac{k_{z,mn}^{\\text{trans}} / \\omega\\mu_{\\text{out}}}{k_{z,\\text{inc}} / \\omega\\mu_{\\text{in}}} |t_{mn}|^2 = \\sum_{mn} \\frac{\\text{Re}(k_{z,mn}^{\\text{trans}}) \\mu_{\\text{in}}}{\\text{Re}(k_{z,\\text{inc}}) \\mu_{\\text{out}}} |t_{mn}|^2 \\] <p>The normalization ensures \\(R + T = 1\\) for lossless structures.</p>"},{"location":"theory/mathematics/#field-reconstruction","title":"Field Reconstruction","text":""},{"location":"theory/mathematics/#fourier-space-fields","title":"Fourier Space Fields","text":"<p>At any position \\((x, y, z)\\) within a layer, fields are:</p> \\[ \\mathbf{E}(x,y,z) = \\sum_{mn} \\mathbf{E}_{mn}(z) \\exp(i k_{x,mn} x + i k_{y,mn} y) \\] <p>where \\(\\mathbf{E}_{mn}(z)\\) are computed from eigenmode expansion.</p>"},{"location":"theory/mathematics/#real-space-fields","title":"Real Space Fields","text":"<p>To get fields on a real-space grid, use inverse FFT:</p> \\[ \\mathbf{E}(x_i, y_j, z) = \\text{IFFT2D}[\\mathbf{E}_{mn}(z)] \\]"},{"location":"theory/mathematics/#volume-integrals","title":"Volume Integrals","text":"<p>For computing volume integrals (e.g., energy density):</p> \\[ \\int_V |\\mathbf{E}|^2 dV = \\sum_{mn} |\\mathbf{E}_{mn}|^2 V_{\\text{unit}} \\] <p>where \\(V_{\\text{unit}} = A_{\\text{cell}} \\cdot d\\) is the unit cell volume.</p>"},{"location":"theory/mathematics/#numerical-stability","title":"Numerical Stability","text":""},{"location":"theory/mathematics/#enhanced-transmittance-matrix","title":"Enhanced Transmittance Matrix","text":"<p>For thick layers, direct exponentials \\(e^{iq_j d}\\) can overflow for large \\(|q_j|\\).</p> <p>Use the Enhanced Transmittance Matrix method:</p> <ul> <li>Scale exponentials by largest \\(q_j\\)</li> <li>Compute ratios rather than absolute values</li> <li>Prevents overflow/underflow</li> </ul>"},{"location":"theory/mathematics/#eigenvalue-ordering","title":"Eigenvalue Ordering","text":"<p>Eigenvalues \\(q_j\\) should be ordered:</p> <ul> <li>Forward propagating: \\(\\text{Re}(q) &gt; 0\\) or \\(\\text{Im}(q) &lt; 0\\)</li> <li>Backward propagating: \\(\\text{Re}(q) &lt; 0\\) or \\(\\text{Im}(q) &gt; 0\\)</li> </ul> <p>This ensures numerical stability in the S-matrix algorithm.</p>"},{"location":"theory/mathematics/#matrix-inversion","title":"Matrix Inversion","text":"<p>Matrices like \\(\\mathcal{E}\\) can be ill-conditioned for:</p> <ul> <li>High contrast structures</li> <li>Large truncation order</li> <li>Thin features</li> </ul> <p>Use regularization or iterative solvers if direct inversion fails.</p>"},{"location":"theory/mathematics/#convergence-acceleration","title":"Convergence Acceleration","text":""},{"location":"theory/mathematics/#adaptive-coordinate-transformation","title":"Adaptive Coordinate Transformation","text":"<p>For gratings with vertical sidewalls, map to \\(u\\)-space:</p> \\[ u(x) = x + \\sum_n a_n \\sin(2\\pi n x / \\Lambda) \\] <p>This smooths out discontinuities and improves convergence.</p>"},{"location":"theory/mathematics/#perfectly-matched-layer-pml","title":"Perfectly Matched Layer (PML)","text":"<p>For absorbing boundaries (not typically used in periodic RCWA):</p> \\[ \\varepsilon \\to \\varepsilon s, \\quad \\mu \\to \\mu s \\] <p>where \\(s = 1 + i\\sigma/\\omega\\) is the PML stretching parameter.</p>"},{"location":"theory/mathematics/#subpixel-smoothing","title":"Subpixel Smoothing","text":"<p>For sharp features, average \\(\\varepsilon\\) over grid cells rather than point sampling:</p> \\[ \\varepsilon_{\\text{cell}} = \\frac{1}{A_{\\text{cell}}} \\int_{\\text{cell}} \\varepsilon(x,y) dx dy \\] <p>Improves convergence for staircasing approximation.</p>"},{"location":"theory/mathematics/#summary-of-key-equations","title":"Summary of Key Equations","text":"Quantity Equation Field expansion \\(\\mathbf{E} = \\sum_{mn} \\mathbf{E}_{mn}(z) e^{i\\mathbf{k}_{mn} \\cdot \\mathbf{r}_\\parallel}\\) Wave vector \\(\\mathbf{k}_{mn} = \\mathbf{k}_{\\parallel,0} + \\mathbf{G}_{mn}\\) Eigenvalue problem \\(AB\\boldsymbol{\\phi} = q^2 \\boldsymbol{\\phi}\\) S-matrix \\(\\begin{pmatrix} \\mathbf{out} \\end{pmatrix} = S \\begin{pmatrix} \\mathbf{in} \\end{pmatrix}\\) Reflection $R = \\sum_{mn} \\frac{\\text{Re}(k_{z,mn}^r)}{\\text{Re}(k_{z,inc})} Transmission $T = \\sum_{mn} \\frac{\\text{Re}(k_{z,mn}^t)}{\\text{Re}(k_{z,inc})} Energy conservation \\(R + T = 1\\) (lossless)"},{"location":"theory/mathematics/#implementation-in-grcwa","title":"Implementation in GRCWA","text":"<p>GRCWA implements these equations in:</p> <ul> <li><code>rcwa.py</code>: Main solver, S-matrix algorithm</li> <li><code>fft_funs.py</code>: Convolution matrices via FFT</li> <li><code>kbloch.py</code>: Reciprocal lattice and wave vectors</li> <li><code>primitives.py</code>: Autograd-compatible eigenvalue solver</li> </ul> <p>Key optimizations:</p> <ul> <li>Fast FFT for convolution matrices</li> <li>Enhanced transmittance matrix for stability</li> <li>Autograd primitives for gradient computation</li> </ul>"},{"location":"theory/mathematics/#further-reading","title":"Further Reading","text":"<p>For derivations and proofs, see:</p> <ul> <li>Moharam et al., \"Formulation for stable and efficient implementation of the rigorous coupled-wave analysis of binary gratings,\" JOSA A (1995)</li> <li>Liu and Fan, \"Three-dimensional photonic crystals by total-internal reflection,\" Optics Letters (2005)</li> <li>Whittaker and Culshaw, \"Scattering-matrix treatment of patterned multilayer photonic structures,\" Phys. Rev. B (1999)</li> </ul>"},{"location":"theory/mathematics/#next-steps","title":"Next Steps","text":"<ul> <li>RCWA Algorithm: Step-by-step computational procedure</li> <li>API Reference: How equations map to code</li> <li>Tutorials: Apply the theory in practice</li> </ul>"},{"location":"theory/principles/","title":"Physical Principles of RCWA","text":"<p>This page explains the physics behind Rigorous Coupled Wave Analysis (RCWA).</p>"},{"location":"theory/principles/#maxwells-equations","title":"Maxwell's Equations","text":"<p>RCWA solves Maxwell's equations for time-harmonic fields with convention \\(e^{-i\\omega t}\\):</p>"},{"location":"theory/principles/#curl-equations","title":"Curl Equations","text":"\\[ \\nabla \\times \\mathbf{E} = i\\omega \\mathbf{B} = i\\omega \\mu \\mathbf{H} \\] \\[ \\nabla \\times \\mathbf{H} = -i\\omega \\mathbf{D} = -i\\omega \\varepsilon \\mathbf{E} \\]"},{"location":"theory/principles/#divergence-equations","title":"Divergence Equations","text":"\\[ \\nabla \\cdot \\mathbf{D} = \\nabla \\cdot (\\varepsilon \\mathbf{E}) = 0 \\] \\[ \\nabla \\cdot \\mathbf{B} = \\nabla \\cdot (\\mu \\mathbf{H}) = 0 \\] <p>In GRCWA's natural units: \\(\\varepsilon_0 = \\mu_0 = c = 1\\)</p>"},{"location":"theory/principles/#wave-equation","title":"Wave Equation","text":"<p>From Maxwell's curl equations, we can derive the vector wave equation:</p> \\[ \\nabla \\times \\nabla \\times \\mathbf{E} - \\omega^2 \\varepsilon \\mathbf{E} = 0 \\] \\[ \\nabla \\times \\nabla \\times \\mathbf{H} - \\omega^2 \\mu \\mathbf{H} = 0 \\] <p>Using the identity \\(\\nabla \\times \\nabla \\times \\mathbf{F} = \\nabla(\\nabla \\cdot \\mathbf{F}) - \\nabla^2 \\mathbf{F}\\):</p> <p>For E-field in uniform media: $$ \\nabla^2 \\mathbf{E} + \\omega^2 \\varepsilon \\mathbf{E} = 0 $$</p> <p>This is the Helmholtz equation with wave number \\(k = \\omega\\sqrt{\\varepsilon}\\).</p>"},{"location":"theory/principles/#periodic-structures","title":"Periodic Structures","text":""},{"location":"theory/principles/#lattice-periodicity","title":"Lattice Periodicity","text":"<p>A photonic crystal has 2D periodicity:</p> \\[ \\varepsilon(\\mathbf{r} + m\\mathbf{L}_1 + n\\mathbf{L}_2) = \\varepsilon(\\mathbf{r}) \\] <p>where \\(m, n \\in \\mathbb{Z}\\) and \\(\\mathbf{L}_1, \\mathbf{L}_2\\) are lattice vectors.</p> <p>Example lattices:</p> <ul> <li>Square: \\(\\mathbf{L}_1 = a\\hat{x}\\), \\(\\mathbf{L}_2 = a\\hat{y}\\)</li> <li>Rectangular: \\(\\mathbf{L}_1 = a\\hat{x}\\), \\(\\mathbf{L}_2 = b\\hat{y}\\)</li> <li>Hexagonal: \\(\\mathbf{L}_1 = a\\hat{x}\\), \\(\\mathbf{L}_2 = a(\\frac{1}{2}\\hat{x} + \\frac{\\sqrt{3}}{2}\\hat{y})\\)</li> </ul>"},{"location":"theory/principles/#reciprocal-lattice","title":"Reciprocal Lattice","text":"<p>The reciprocal lattice vectors satisfy:</p> \\[ \\mathbf{K}_i \\cdot \\mathbf{L}_j = 2\\pi \\delta_{ij} \\] <p>For 2D lattices embedded in 3D:</p> \\[ \\mathbf{K}_1 = 2\\pi \\frac{\\mathbf{L}_2 \\times \\hat{z}}{|\\mathbf{L}_1 \\times \\mathbf{L}_2 \\cdot \\hat{z}|} \\] \\[ \\mathbf{K}_2 = 2\\pi \\frac{\\hat{z} \\times \\mathbf{L}_1}{|\\mathbf{L}_1 \\times \\mathbf{L}_2 \\cdot \\hat{z}|} \\] <p>The reciprocal lattice vectors are:</p> \\[ \\mathbf{G}_{mn} = m\\mathbf{K}_1 + n\\mathbf{K}_2, \\quad m,n \\in \\mathbb{Z} \\]"},{"location":"theory/principles/#blochs-theorem","title":"Bloch's Theorem","text":""},{"location":"theory/principles/#bloch-waves","title":"Bloch Waves","text":"<p>In periodic structures, electromagnetic modes are Bloch waves:</p> \\[ \\mathbf{E}(\\mathbf{r}) = e^{i\\mathbf{k}_\\parallel \\cdot \\mathbf{r}_\\parallel} \\mathbf{u}(\\mathbf{r}) \\] <p>where:</p> <ul> <li>\\(\\mathbf{k}_\\parallel = k_x\\hat{x} + k_y\\hat{y}\\) is the Bloch wave vector</li> <li>\\(\\mathbf{u}(\\mathbf{r})\\) has the same periodicity as the structure: \\(\\mathbf{u}(\\mathbf{r} + \\mathbf{L}) = \\mathbf{u}(\\mathbf{r})\\)</li> </ul>"},{"location":"theory/principles/#floquet-bloch-theorem","title":"Floquet-Bloch Theorem","text":"<p>Since \\(\\mathbf{u}(\\mathbf{r})\\) is periodic, it can be expanded in a Fourier series:</p> \\[ \\mathbf{E}(\\mathbf{r}) = e^{i\\mathbf{k}_\\parallel \\cdot \\mathbf{r}_\\parallel} \\sum_{mn} \\mathbf{E}_{mn}(z) e^{i\\mathbf{G}_{mn} \\cdot \\mathbf{r}_\\parallel} \\] \\[ = \\sum_{mn} \\mathbf{E}_{mn}(z) e^{i(\\mathbf{k}_\\parallel + \\mathbf{G}_{mn}) \\cdot \\mathbf{r}_\\parallel} \\] <p>Define Bloch wave vectors:</p> \\[ \\mathbf{k}_{mn,\\parallel} = \\mathbf{k}_\\parallel + \\mathbf{G}_{mn} \\] <p>Each \\((m,n)\\) is a diffraction order or Floquet harmonic.</p>"},{"location":"theory/principles/#diffraction-and-propagation","title":"Diffraction and Propagation","text":""},{"location":"theory/principles/#in-plane-wave-vectors","title":"In-Plane Wave Vectors","text":"<p>For incident plane wave with angles \\((\\theta, \\phi)\\) in a medium with \\(\\varepsilon_{\\text{in}}\\):</p> \\[ k_{x0} = \\omega\\sqrt{\\varepsilon_{\\text{in}}} \\sin\\theta \\cos\\phi \\] \\[ k_{y0} = \\omega\\sqrt{\\varepsilon_{\\text{in}}} \\sin\\theta \\sin\\phi \\] <p>Each diffraction order has in-plane wave vector:</p> \\[ k_{x,mn} = k_{x0} + G_{x,mn} \\] \\[ k_{y,mn} = k_{y0} + G_{y,mn} \\]"},{"location":"theory/principles/#z-component-of-wave-vector","title":"Z-Component of Wave Vector","text":"<p>From the dispersion relation in a medium with \\(\\varepsilon\\):</p> \\[ k_{x,mn}^2 + k_{y,mn}^2 + k_{z,mn}^2 = \\varepsilon \\omega^2 \\] <p>Therefore:</p> \\[ k_{z,mn} = \\pm\\sqrt{\\varepsilon \\omega^2 - k_{x,mn}^2 - k_{y,mn}^2} \\] <p>Two cases:</p> <ol> <li>Propagating modes: \\(k_{x,mn}^2 + k_{y,mn}^2 &lt; \\varepsilon\\omega^2\\) \u2192 \\(k_z\\) is real</li> <li>Carries power to far field</li> <li> <p>Contributes to reflection/transmission</p> </li> <li> <p>Evanescent modes: \\(k_{x,mn}^2 + k_{y,mn}^2 &gt; \\varepsilon\\omega^2\\) \u2192 \\(k_z\\) is imaginary</p> </li> <li>Decays exponentially: \\(e^{-|\\text{Im}(k_z)|z}\\)</li> <li>Stores near-field energy</li> <li>Important for field distributions but doesn't contribute to R/T</li> </ol>"},{"location":"theory/principles/#physical-interpretation","title":"Physical Interpretation","text":"<p>Think of diffraction orders as different \"beams\" produced by the periodic structure:</p> <ul> <li>0<sup>th</sup> order \\((m=0, n=0)\\): Main transmitted/reflected beam</li> <li>Higher orders \\((m,n \\neq 0)\\): Diffracted beams at angles determined by \\(\\mathbf{k}_{mn}\\)</li> </ul> <p>At low frequencies (long wavelengths), most orders are evanescent. At high frequencies, many orders can propagate.</p>"},{"location":"theory/principles/#polarization","title":"Polarization","text":""},{"location":"theory/principles/#s-and-p-polarization","title":"S and P Polarization","text":"<p>For plane waves, we decompose into two orthogonal polarizations:</p> <p>S-polarization (TE): Electric field perpendicular to plane of incidence</p> <ul> <li>For normal incidence with \\(\\mathbf{k} \\parallel \\hat{z}\\): \\(\\mathbf{E} \\parallel \\hat{x}\\) or \\(\\hat{y}\\)</li> </ul> <p>P-polarization (TM): Magnetic field perpendicular to plane of incidence</p> <ul> <li>Electric field in the plane of incidence</li> </ul>"},{"location":"theory/principles/#general-polarization-state","title":"General Polarization State","text":"<p>An arbitrary polarization is a superposition:</p> \\[ \\mathbf{E} = A_s e^{i\\phi_s} \\hat{s} + A_p e^{i\\phi_p} \\hat{p} \\] <p>Linear polarization: \\(\\phi_p - \\phi_s = 0\\) or \\(\\pi\\)</p> <p>Circular polarization: \\(A_p = A_s\\), \\(\\phi_p - \\phi_s = \\pm\\pi/2\\)</p> <p>Elliptical polarization: General case</p>"},{"location":"theory/principles/#energy-and-power-flow","title":"Energy and Power Flow","text":""},{"location":"theory/principles/#poynting-vector","title":"Poynting Vector","text":"<p>The time-averaged Poynting vector is:</p> \\[ \\langle\\mathbf{S}\\rangle = \\frac{1}{2} \\text{Re}(\\mathbf{E} \\times \\mathbf{H}^*) \\] <p>This gives the electromagnetic power flow (energy per area per time).</p>"},{"location":"theory/principles/#power-in-each-order","title":"Power in Each Order","text":"<p>For each diffraction order \\((m,n)\\):</p> \\[ P_{mn} = \\frac{1}{2} \\text{Re}\\left( E_{x,mn} H_{y,mn}^* - E_{y,mn} H_{x,mn}^* \\right) \\cdot \\frac{A_{\\text{cell}}}{\\cos\\theta_{mn}} \\] <p>where:</p> <ul> <li>\\(A_{\\text{cell}} = |\\mathbf{L}_1 \\times \\mathbf{L}_2|\\) is the unit cell area</li> <li>\\(\\theta_{mn}\\) is the propagation angle of order \\((m,n)\\)</li> </ul>"},{"location":"theory/principles/#reflection-and-transmission","title":"Reflection and Transmission","text":"<p>Total reflected power:</p> \\[ R = \\sum_{mn} \\frac{P_{mn}^{\\text{refl}}}{P_{\\text{inc}}} \\] <p>Total transmitted power:</p> \\[ T = \\sum_{mn} \\frac{P_{mn}^{\\text{trans}}}{P_{\\text{inc}}} \\] <p>For lossless structures: \\(R + T = 1\\) (energy conservation)</p>"},{"location":"theory/principles/#boundary-conditions","title":"Boundary Conditions","text":""},{"location":"theory/principles/#tangential-field-continuity","title":"Tangential Field Continuity","text":"<p>At interfaces between layers, tangential components must be continuous:</p> \\[ \\mathbf{n} \\times (\\mathbf{E}_1 - \\mathbf{E}_2) = 0 \\] \\[ \\mathbf{n} \\times (\\mathbf{H}_1 - \\mathbf{H}_2) = 0 \\] <p>where \\(\\mathbf{n}\\) is the interface normal.</p> <p>For horizontal interfaces (\\(\\mathbf{n} = \\hat{z}\\)):</p> \\[ E_x, E_y, H_x, H_y \\text{ continuous} \\]"},{"location":"theory/principles/#normal-field-discontinuity","title":"Normal Field Discontinuity","text":"<p>Normal components satisfy:</p> \\[ \\mathbf{n} \\cdot (\\varepsilon_1 \\mathbf{E}_1 - \\varepsilon_2 \\mathbf{E}_2) = 0 \\] \\[ \\mathbf{n} \\cdot (\\mu_1 \\mathbf{H}_1 - \\mu_2 \\mathbf{H}_2) = 0 \\] <p>For dielectric contrast, \\(D_z = \\varepsilon E_z\\) is continuous, but \\(E_z\\) is not.</p>"},{"location":"theory/principles/#layer-structure-in-rcwa","title":"Layer Structure in RCWA","text":""},{"location":"theory/principles/#uniform-layers","title":"Uniform Layers","text":"<p>For layers with constant \\(\\varepsilon(z) = \\varepsilon_0\\):</p> <ul> <li>Analytical eigenmode solution</li> <li>Modes are forward/backward propagating plane waves</li> <li>Fast and stable</li> </ul>"},{"location":"theory/principles/#patterned-layers","title":"Patterned Layers","text":"<p>For layers with \\(\\varepsilon(x,y,z) = \\varepsilon(x,y)\\) (z-invariant):</p> <ul> <li>Must solve eigenvalue problem numerically</li> <li>Modes are Bloch waves with different \\(k_z\\)</li> <li>More computationally expensive</li> </ul>"},{"location":"theory/principles/#layer-stacking","title":"Layer Stacking","text":"<p>RCWA treats the structure as a stack:</p> <pre><code>Input region (uniform)\n\u2193\nLayer 1 (uniform or patterned)\n\u2193\nLayer 2 (uniform or patterned)\n\u2193\n...\n\u2193\nLayer N (uniform or patterned)\n\u2193\nOutput region (uniform)\n</code></pre> <p>Each layer is solved independently, then coupled via boundary conditions.</p>"},{"location":"theory/principles/#truncation-and-convergence","title":"Truncation and Convergence","text":""},{"location":"theory/principles/#fourier-truncation","title":"Fourier Truncation","text":"<p>In practice, we truncate the infinite Fourier series:</p> \\[ \\mathbf{E}(\\mathbf{r}) = \\sum_{m=-M}^{M} \\sum_{n=-N}^{N} \\mathbf{E}_{mn}(z) e^{i\\mathbf{k}_{mn} \\cdot \\mathbf{r}_\\parallel} \\] <p>The truncation order \\(N_G = (2M+1)(2N+1)\\) determines accuracy and computational cost.</p>"},{"location":"theory/principles/#convergence-behavior","title":"Convergence Behavior","text":"<p>Smooth features: Fast convergence, small \\(N_G\\) sufficient</p> <p>Sharp features: Slow convergence, large \\(N_G\\) needed (Gibbs phenomenon)</p> <p>Deep subwavelength: Very large \\(N_G\\) may be required</p> <p>Rule of thumb: Start with \\(N_G \\sim 101\\), increase until results converge</p>"},{"location":"theory/principles/#physical-insights","title":"Physical Insights","text":""},{"location":"theory/principles/#why-rcwa-works","title":"Why RCWA Works","text":"<ol> <li>Periodicity reduces dimensionality: 3D problem \u2192 unit cell + Bloch theorem</li> <li>Fourier representation: Efficient for smooth dielectric profiles</li> <li>Layer-wise: Complex 3D structure \u2192 stack of 2D problems</li> <li>Rigorous: Solves Maxwell's equations exactly (within truncation)</li> </ol>"},{"location":"theory/principles/#when-rcwa-excels","title":"When RCWA Excels","text":"<ul> <li>High-Q resonances: Captures sharp spectral features</li> <li>Subwavelength structures: Handles near-field correctly</li> <li>Multiple diffraction orders: Analyzes each order separately</li> <li>Arbitrary patterns: No restriction on shape (with grid method)</li> </ul>"},{"location":"theory/principles/#limitations","title":"Limitations","text":"<ul> <li>Requires periodicity: Can't simulate isolated objects directly (use super-cell)</li> <li>Convergence for sharp edges: May need high truncation order</li> <li>Frequency domain: Time-domain requires Fourier transform</li> </ul>"},{"location":"theory/principles/#summary","title":"Summary","text":"<p>RCWA solves Maxwell's equations for periodic structures by:</p> <ol> <li>Expanding fields in Floquet-Bloch modes (diffraction orders)</li> <li>Fourier transforming the dielectric profile</li> <li>Solving eigenvalue problems for each layer</li> <li>Matching boundary conditions between layers</li> <li>Computing power flow in each diffraction order</li> </ol> <p>The result is a rigorous, efficient method for simulating periodic photonic structures.</p>"},{"location":"theory/principles/#next-topics","title":"Next Topics","text":"<ul> <li>Mathematical Formulation: Detailed equations and derivations</li> <li>RCWA Algorithm: Step-by-step computational procedure</li> <li>Basic Concepts: Practical implementation guide</li> </ul>"},{"location":"tutorials/tutorial1/","title":"Tutorial 1: Simple Dielectric Slab","text":"<p>In this tutorial, you'll learn the basics of GRCWA by simulating a simple dielectric slab.</p>"},{"location":"tutorials/tutorial1/#learning-objectives","title":"Learning Objectives","text":"<p>By the end of this tutorial, you will:</p> <ul> <li>Understand the basic GRCWA workflow</li> <li>Create uniform dielectric layers</li> <li>Compute reflection and transmission</li> <li>Verify energy conservation</li> <li>Understand the Fabry-P\u00e9rot effect</li> </ul>"},{"location":"tutorials/tutorial1/#physical-system","title":"Physical System","text":"<p>We'll simulate a dielectric slab (like a glass plate) in vacuum:</p> <pre><code>        Air (\u03b5=1)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502   Slab (\u03b5=4)    \u2502  thickness = 0.5\u03bb\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        Air (\u03b5=1)\n</code></pre> <p>Parameters:</p> <ul> <li>Wavelength: \u03bb = 1.0 \u03bcm</li> <li>Slab: Silicon (n=2, \u03b5=4), thickness = 0.5 \u03bcm</li> <li>Incidence: Normal (\u03b8=0)</li> <li>Polarization: P-polarized</li> </ul>"},{"location":"tutorials/tutorial1/#step-1-import-and-setup","title":"Step 1: Import and Setup","text":"<pre><code>import grcwa\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Set backend (use 'numpy' for speed, 'autograd' for gradients)\ngrcwa.set_backend('numpy')\n</code></pre>"},{"location":"tutorials/tutorial1/#step-2-define-structure","title":"Step 2: Define Structure","text":"<pre><code># Physical parameters\nwavelength = 1.0      # \u03bcm\nfreq = 1.0 / wavelength  # frequency in natural units\n\n# Lattice vectors (arbitrary for uniform slab)\nL1 = [1.0, 0]\nL2 = [0, 1.0]\n\n# Incident angles (normal incidence)\ntheta = 0.0\nphi = 0.0\n\n# Truncation order (small value OK for uniform layers)\nnG = 51\n\n# Create RCWA object\nobj = grcwa.obj(nG, L1, L2, freq, theta, phi, verbose=1)\n</code></pre> <p>Explanation:</p> <ul> <li><code>freq = 1.0/wavelength</code>: Converts wavelength to frequency</li> <li><code>L1, L2</code>: Periodicity doesn't matter for uniform structure</li> <li><code>nG = 51</code>: Small truncation order sufficient for uniform layers</li> <li><code>verbose=1</code>: Print progress information</li> </ul>"},{"location":"tutorials/tutorial1/#step-3-add-layers","title":"Step 3: Add Layers","text":"<pre><code># Layer thicknesses\nthickness_top = 1.0      # Semi-infinite vacuum\nthickness_slab = 0.5     # Slab thickness = \u03bb/2\nthickness_bottom = 1.0   # Semi-infinite vacuum\n\n# Dielectric constants\neps_vacuum = 1.0\neps_slab = 4.0  # n=2, so \u03b5=n\u00b2=4\n\n# Add layers (top to bottom)\nobj.Add_LayerUniform(thickness_top, eps_vacuum)\nobj.Add_LayerUniform(thickness_slab, eps_slab)\nobj.Add_LayerUniform(thickness_bottom, eps_vacuum)\n</code></pre> <p>Layer ordering:</p> <ol> <li>Input layer (vacuum above slab)</li> <li>Slab layer (dielectric)</li> <li>Output layer (vacuum below slab)</li> </ol> <p>Note: First and last layers are treated as semi-infinite regions.</p>"},{"location":"tutorials/tutorial1/#step-4-initialize","title":"Step 4: Initialize","text":"<pre><code># Initialize reciprocal lattice and eigenvalues\nobj.Init_Setup()\n\nprint(f\"Actual nG used: {obj.nG}\")\nprint(f\"Angular frequency: {obj.omega:.4f}\")\n</code></pre> <p>This computes:</p> <ul> <li>Reciprocal lattice vectors</li> <li>Wave vectors for all diffraction orders</li> <li>Eigenvalues and eigenvectors for each layer</li> </ul>"},{"location":"tutorials/tutorial1/#step-5-define-excitation","title":"Step 5: Define Excitation","text":"<pre><code># P-polarized plane wave\np_amp = 1.0\np_phase = 0.0\ns_amp = 0.0\ns_phase = 0.0\n\nobj.MakeExcitationPlanewave(p_amp, p_phase, s_amp, s_phase, order=0)\n</code></pre> <p>Polarizations:</p> <ul> <li>P-polarized (TM): Electric field in plane of incidence</li> <li>S-polarized (TE): Electric field perpendicular to plane of incidence</li> </ul> <p>For normal incidence, choice doesn't matter for isotropic materials.</p>"},{"location":"tutorials/tutorial1/#step-6-solve","title":"Step 6: Solve","text":"<pre><code># Compute reflection and transmission\nR, T = obj.RT_Solve(normalize=1)\n\nprint(\"\\n\" + \"=\"*50)\nprint(f\"Reflection (R): {R:.6f}\")\nprint(f\"Transmission (T): {T:.6f}\")\nprint(f\"Sum (R+T): {R+T:.6f}\")\nprint(f\"Energy conservation error: {abs(R+T-1):.2e}\")\nprint(\"=\"*50)\n</code></pre> <p>Expected output:</p> <pre><code>==================================================\nReflection (R): 0.055556\nTransmission (T): 0.944444\nSum (R+T): 1.000000\nEnergy conservation error: 0.00e+00\n==================================================\n</code></pre>"},{"location":"tutorials/tutorial1/#step-7-analytical-verification","title":"Step 7: Analytical Verification","text":"<p>For a dielectric slab, we can compute R, T analytically using Fresnel equations and Fabry-P\u00e9rot formula.</p> <pre><code>def analytical_slab_RT(n_slab, thickness, wavelength, n_in=1.0, n_out=1.0):\n    \"\"\"\n    Analytical R, T for a dielectric slab at normal incidence.\n    \"\"\"\n    # Refractive index\n    n = n_slab\n    k0 = 2 * np.pi / wavelength\n    kz = n * k0\n    delta = kz * thickness  # Phase thickness\n\n    # Fresnel coefficients at interfaces\n    r12 = (n_in - n) / (n_in + n)  # Air -&gt; slab\n    r23 = (n - n_out) / (n + n_out)  # Slab -&gt; air\n    t12 = 2*n_in / (n_in + n)\n    t23 = 2*n / (n + n_out)\n\n    # Fabry-P\u00e9rot formula\n    numerator_r = r12 + r23 * np.exp(2j * delta)\n    denominator = 1 + r12 * r23 * np.exp(2j * delta)\n    r_total = numerator_r / denominator\n\n    numerator_t = t12 * t23 * np.exp(1j * delta)\n    t_total = numerator_t / denominator\n\n    R = np.abs(r_total)**2\n    T = (n_out / n_in) * np.abs(t_total)**2\n\n    return R, T\n\n# Compute analytical result\nn_slab = 2.0  # sqrt(4.0)\nR_analytical, T_analytical = analytical_slab_RT(n_slab, thickness_slab, wavelength)\n\nprint(\"\\nAnalytical result:\")\nprint(f\"R_analytical = {R_analytical:.6f}\")\nprint(f\"T_analytical = {T_analytical:.6f}\")\nprint(f\"\\nDifference:\")\nprint(f\"\u0394R = {abs(R - R_analytical):.2e}\")\nprint(f\"\u0394T = {abs(T - T_analytical):.2e}\")\n</code></pre> <p>Expected output:</p> <pre><code>Analytical result:\nR_analytical = 0.055556\nT_analytical = 0.944444\n\nDifference:\n\u0394R = 1.39e-17\n\u0394T = 2.78e-17\n</code></pre> <p>Perfect agreement! This validates our RCWA simulation.</p>"},{"location":"tutorials/tutorial1/#step-8-spectral-response","title":"Step 8: Spectral Response","text":"<p>Let's compute R and T vs. wavelength to see Fabry-P\u00e9rot fringes:</p> <pre><code># Wavelength sweep\nwavelengths = np.linspace(0.5, 2.0, 200)  # \u03bcm\nR_spectrum = []\nT_spectrum = []\nR_analytical_spectrum = []\n\nfor wl in wavelengths:\n    freq = 1.0 / wl\n\n    # RCWA calculation\n    obj_sweep = grcwa.obj(nG, L1, L2, freq, theta, phi, verbose=0)\n    obj_sweep.Add_LayerUniform(thickness_top, eps_vacuum)\n    obj_sweep.Add_LayerUniform(thickness_slab, eps_slab)\n    obj_sweep.Add_LayerUniform(thickness_bottom, eps_vacuum)\n    obj_sweep.Init_Setup()\n    obj_sweep.MakeExcitationPlanewave(p_amp, p_phase, s_amp, s_phase, order=0)\n\n    R, T = obj_sweep.RT_Solve(normalize=1)\n    R_spectrum.append(R)\n    T_spectrum.append(T)\n\n    # Analytical\n    R_an, T_an = analytical_slab_RT(n_slab, thickness_slab, wl)\n    R_analytical_spectrum.append(R_an)\n\n# Plot\nplt.figure(figsize=(10, 6))\nplt.plot(wavelengths, R_spectrum, 'b-', linewidth=2, label='R (RCWA)')\nplt.plot(wavelengths, T_spectrum, 'r-', linewidth=2, label='T (RCWA)')\nplt.plot(wavelengths, R_analytical_spectrum, 'ko', markersize=3,\n         markevery=10, label='R (Analytical)')\n\nplt.xlabel('Wavelength (\u03bcm)', fontsize=12)\nplt.ylabel('Power', fontsize=12)\nplt.title('Fabry-P\u00e9rot Fringes in Dielectric Slab', fontsize=14)\nplt.legend(fontsize=11)\nplt.grid(True, alpha=0.3)\nplt.xlim(0.5, 2.0)\nplt.ylim(0, 1)\n\n# Mark special wavelengths\n# When thickness = m*\u03bb/(2n), we have constructive interference -&gt; minimum R\nlambda_min = 2 * n_slab * thickness_slab / np.arange(1, 5)\nfor lm in lambda_min:\n    if 0.5 &lt; lm &lt; 2.0:\n        plt.axvline(lm, color='gray', linestyle='--', alpha=0.5)\n        plt.text(lm, 0.95, f'\u03bb={lm:.2f}', fontsize=9, ha='center')\n\nplt.tight_layout()\nplt.savefig('tutorial1_spectrum.png', dpi=150)\nplt.show()\n</code></pre> <p>What you'll see:</p> <ul> <li>Oscillating R and T (Fabry-P\u00e9rot fringes)</li> <li>Minima in R when thickness = m\u03bb/(2n) (constructive interference)</li> <li>Perfect agreement between RCWA and analytical</li> </ul>"},{"location":"tutorials/tutorial1/#understanding-the-physics","title":"Understanding the Physics","text":""},{"location":"tutorials/tutorial1/#fabry-perot-effect","title":"Fabry-P\u00e9rot Effect","text":"<p>Light bounces between the two interfaces of the slab, creating interference:</p> <ul> <li> <p>Constructive interference: When optical path = integer \u00d7 wavelength</p> <ul> <li>Thickness = m \u00d7 \u03bb/(2n)</li> <li>Maximum transmission, minimum reflection</li> </ul> </li> <li> <p>Destructive interference: When optical path = half-integer \u00d7 wavelength</p> <ul> <li>Thickness = (m + \u00bd) \u00d7 \u03bb/(2n)</li> <li>Minimum transmission, maximum reflection</li> </ul> </li> </ul>"},{"location":"tutorials/tutorial1/#fresnel-reflection","title":"Fresnel Reflection","text":"<p>At each air-slab interface, Fresnel coefficient:</p> \\[ r = \\frac{n_1 - n_2}{n_1 + n_2} \\] <p>For n=2:</p> \\[ r = \\frac{1-2}{1+2} = -\\frac{1}{3} \\] \\[ R_{\\text{single interface}} = |r|^2 = \\frac{1}{9} \\approx 0.111 \\] <p>But with two interfaces and interference, \\(R \\approx 0.056\\) at \u03bb = 1.0 \u03bcm.</p>"},{"location":"tutorials/tutorial1/#exercise-1-change-thickness","title":"Exercise 1: Change Thickness","text":"<p>Modify the slab thickness and observe how it affects R and T:</p> <pre><code>thicknesses = [0.25, 0.5, 0.75, 1.0]  # in units of \u03bb\n\nfor thickness in thicknesses:\n    obj_ex = grcwa.obj(nG, L1, L2, freq, theta, phi, verbose=0)\n    obj_ex.Add_LayerUniform(1.0, eps_vacuum)\n    obj_ex.Add_LayerUniform(thickness, eps_slab)\n    obj_ex.Add_LayerUniform(1.0, eps_vacuum)\n    obj_ex.Init_Setup()\n    obj_ex.MakeExcitationPlanewave(1, 0, 0, 0, 0)\n    R, T = obj_ex.RT_Solve(normalize=1)\n    print(f\"Thickness = {thickness:.2f}\u03bb: R = {R:.4f}, T = {T:.4f}\")\n</code></pre>"},{"location":"tutorials/tutorial1/#exercise-2-change-refractive-index","title":"Exercise 2: Change Refractive Index","text":"<p>Try different slab materials:</p> <pre><code>refractive_indices = [1.5, 2.0, 3.0, 3.5]  # Glass, Si, GaAs, Si at IR\n\nfor n in refractive_indices:\n    eps = n**2\n    obj_ex = grcwa.obj(nG, L1, L2, freq, theta, phi, verbose=0)\n    obj_ex.Add_LayerUniform(1.0, eps_vacuum)\n    obj_ex.Add_LayerUniform(0.5, eps)\n    obj_ex.Add_LayerUniform(1.0, eps_vacuum)\n    obj_ex.Init_Setup()\n    obj_ex.MakeExcitationPlanewave(1, 0, 0, 0, 0)\n    R, T = obj_ex.RT_Solve(normalize=1)\n    print(f\"n = {n:.1f}: R = {R:.4f}, T = {T:.4f}\")\n</code></pre> <p>Observation: Higher refractive index \u2192 higher reflection.</p>"},{"location":"tutorials/tutorial1/#exercise-3-oblique-incidence","title":"Exercise 3: Oblique Incidence","text":"<p>What happens at an angle?</p> <pre><code>angles = np.linspace(0, 80, 50) * np.pi/180\n\nR_p_list = []\nR_s_list = []\n\nfor theta in angles:\n    obj_angle = grcwa.obj(nG, L1, L2, freq, theta, phi=0, verbose=0)\n    obj_angle.Add_LayerUniform(1.0, eps_vacuum)\n    obj_angle.Add_LayerUniform(0.5, eps_slab)\n    obj_angle.Add_LayerUniform(1.0, eps_vacuum)\n    obj_angle.Init_Setup()\n\n    # P-polarization\n    obj_angle.MakeExcitationPlanewave(1, 0, 0, 0, 0)\n    R_p, _ = obj_angle.RT_Solve(normalize=1)\n    R_p_list.append(R_p)\n\n    # S-polarization\n    obj_angle.MakeExcitationPlanewave(0, 0, 1, 0, 0)\n    R_s, _ = obj_angle.RT_Solve(normalize=1)\n    R_s_list.append(R_s)\n\nplt.figure(figsize=(8, 6))\nplt.plot(angles*180/np.pi, R_p_list, 'b-', label='P-polarization')\nplt.plot(angles*180/np.pi, R_s_list, 'r-', label='S-polarization')\nplt.xlabel('Incident Angle (degrees)')\nplt.ylabel('Reflectance')\nplt.title('Angle-Dependent Reflection')\nplt.legend()\nplt.grid(True, alpha=0.3)\nplt.show()\n</code></pre> <p>Observation: Brewster's angle for P-polarization, total internal reflection at grazing angles.</p>"},{"location":"tutorials/tutorial1/#summary","title":"Summary","text":"<p>In this tutorial, you learned:</p> <p>\u2705 How to create a basic RCWA simulation \u2705 Add uniform dielectric layers \u2705 Compute reflection and transmission \u2705 Verify results against analytical formulas \u2705 Compute spectral response (Fabry-P\u00e9rot fringes) \u2705 Understand physical phenomena (interference, Fresnel reflection)</p>"},{"location":"tutorials/tutorial1/#next-steps","title":"Next Steps","text":"<ul> <li>Tutorial 2: Patterned layer with holes</li> <li>Tutorial 3: Multiple patterned layers</li> <li>Tutorial 4: Hexagonal lattices</li> <li>Tutorial 5: Topology optimization</li> </ul>"},{"location":"tutorials/tutorial1/#complete-code","title":"Complete Code","text":"Click to expand full code <pre><code>import grcwa\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Setup\ngrcwa.set_backend('numpy')\n\nwavelength = 1.0\nfreq = 1.0 / wavelength\nL1 = [1.0, 0]\nL2 = [0, 1.0]\ntheta = 0.0\nphi = 0.0\nnG = 51\n\nobj = grcwa.obj(nG, L1, L2, freq, theta, phi, verbose=1)\n\n# Layers\nthickness_slab = 0.5\neps_vacuum = 1.0\neps_slab = 4.0\n\nobj.Add_LayerUniform(1.0, eps_vacuum)\nobj.Add_LayerUniform(thickness_slab, eps_slab)\nobj.Add_LayerUniform(1.0, eps_vacuum)\n\n# Initialize\nobj.Init_Setup()\n\n# Excitation\nobj.MakeExcitationPlanewave(1, 0, 0, 0, 0)\n\n# Solve\nR, T = obj.RT_Solve(normalize=1)\nprint(f\"R = {R:.6f}, T = {T:.6f}, R+T = {R+T:.6f}\")\n\n# Analytical verification\nn_slab = 2.0\nk0 = 2 * np.pi / wavelength\nkz = n_slab * k0\ndelta = kz * thickness_slab\n\nr12 = (1 - n_slab) / (1 + n_slab)\nr23 = (n_slab - 1) / (n_slab + 1)\nt12 = 2 / (1 + n_slab)\nt23 = 2*n_slab / (n_slab + 1)\n\nr_total = (r12 + r23 * np.exp(2j * delta)) / (1 + r12 * r23 * np.exp(2j * delta))\nt_total = (t12 * t23 * np.exp(1j * delta)) / (1 + r12 * r23 * np.exp(2j * delta))\n\nR_analytical = np.abs(r_total)**2\nT_analytical = np.abs(t_total)**2\n\nprint(f\"R_analytical = {R_analytical:.6f}\")\nprint(f\"T_analytical = {T_analytical:.6f}\")\nprint(f\"Error: \u0394R = {abs(R-R_analytical):.2e}\")\n</code></pre>"}]}